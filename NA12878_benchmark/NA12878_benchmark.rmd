---
title: "Benchmarking Structural Variant Callers using NA12878 WGS reference"
author: 
  #David Fuh, <br/>
  #Summer Intern, <br/>
  #Garvan Institute of Medical Research, 
  #Kinghorn Centre for Clinical Genomics, 
  #Sydney, NSW, Australia
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---
```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
                 fig.path   = 'figure/'
               #, cache.path = 'cache/'
               #, cache      = FALSE
               , dev        = 'png'
               , fig.align  = 'center'
               , fig.show   = 'hold'
               #, fig.width  = 8
               #, fig.height = 6
               #, out.width  = '.8\\linewidth'
               , par        = TRUE
               , echo       = TRUE ## toggle
               , warning    = FALSE
               , message    = FALSE
               )
```


# Packages
```{r Packages}
library(tidyverse)
library(paletteer)
library(GenomicRanges)
library(StructuralVariantAnnotation)
```

# Truth SV set of NA12878

## BED files (CHROM, POS, END)

- Personalis_deletions_hg38.bed
- Spiral_Genetics_insertions_hg38.bed

```{r READ IN Truth SV set NA12878}
setwd("~/GitRepo/summerproject2021/NA12878_benchmark/Maestro_scripts/VCF")

personalis <- read.table("Personalis_deletions_hg38.bed")
spiral <- read.table("Spiral_Genetics_insertions_hg38.bed")
```

```{r}
# join? don't join?

```

```{r}
# renaming cols

```



# Benchmarking the big 4: "Delly, Manta, Melt, Wham"

## BreakpointRanges
```{r caller_svgr generation}
setwd("~/GitRepo/summerproject2021/NA12878_benchmark/Maestro_scripts/VCF")

delly_vcf <- readVcf("NA12878.delly.vcf")
delly_svgr <- breakpointRanges(delly_vcf)

manta_vcf <- readVcf("NA12878.manta.vcf")
manta_svgr <- breakpointRanges(manta_vcf)

melt_vcf <- readVcf("NA12878.melt.vcf")
melt_svgr <- breakpointRanges(melt_vcf)

wham_vcf <- readVcf("NA12878.wham.vcf")
wham_svgr <- breakpointRanges(wham_vcf)

#svaba_vcf <- readVcf("NA12878_small.svaba.vcf")
#svaba_svgr <- breakpointRanges(svaba_vcf)
```

## partner
```{r partner}
partner(delly_svgr)
partner(delly_svgr, selfPartnerSingleBreakends = TRUE)
```

## Ensuring breakpoint consistency
```{r countBreakpointOverlaps}
NAS_delly_chr6_breakpoints <- delly_svgr[seqnames(delly_svgr) == "chr6"]
# A call to findBreakpointOverlaps(colo828_chr6_breakpoints, colo828_chr6_breakpoints)
# will fail as there are a) single breakends, and b) breakpoints with missing partners
NAS_chr6_breakpoints <- NAS_delly_chr6_breakpoints[hasPartner(NAS_delly_chr6_breakpoints)]
# As expected, each call on chr6 only overlaps with itself
countBreakpointOverlaps(NAS_chr6_breakpoints, NAS_chr6_breakpoints)
#> [1] 1 1 1 1 1 1
```

---extracted content below---

> Note that if you did want to include inter-chromosomal breakpoints involving chromosome 6, you would need to update the filtering criteria to include records with chr6 on either side. In such cases, the filtering logic can be simplified by the selfPartnerSingleBreakends parameter of **partner**(). When **selfPartnerSingleBreakends**=TRUE, the partner of single breakend events is considered to be the single breakend itself.

---end of extracted content---


## Benchmarking: Recall
```{r Assigning callers to svgr}
# assign caller info
delly_svgr$Caller <- "Delly"
manta_svgr$Caller <- "Manta"
melt_svgr$Caller <- "Melt"
wham_svgr$Caller <- "Wham"
```

```{r}
# truth svgr
# 1. Personalis
truth_svgr <- GenomicRanges::GRanges(
  seqnames = personalis$V1, 
  ranges=IRanges(start=personalis$V2, end=personalis$V3)
  )
```

```{r}
# 2. Spiral
truth_svgr <- GenomicRanges::GRanges(
  seqnames = spiral$V1, 
  ranges=IRanges(start=spiral$V2, end=spiral$V3)
  )
```


```{r svgr and truth_matches}
# countBreakpointOverlaps
svgr <- c(delly_svgr, manta_svgr, melt_svgr, wham_svgr)

svgr$truth_matches <- countBreakpointOverlaps(svgr, truth_svgr,
  # read pair based callers make imprecise calls.
  # A margin around the call position is required when matching with the truth set
  maxgap=100,
  # Since we added a maxgap, we also need to restrict the mismatch between the
  # size of the events. We don't want to match a 100bp deletion with a
  # 5bp duplication. This will happen if we have a 100bp margin but don't also
  # require an approximate size match as well
  sizemargin=0.25,
  # We also don't want to match a 20bp deletion with a 20bp deletion 80bp away
  # by restricting the margin based on the size of the event, we can make sure
  # that simple events actually do overlap
  restrictMarginToSizeMultiple=0.5,
  # HYDRA makes duplicate calls and will sometimes report a variant multiple
  # times with slightly different bounds. countOnlyBest prevents these being
  # double-counted as multiple true positives.
  countOnlyBest=TRUE)
```

```{r Precision-Recall plot}
# plot
ggplot(as.data.frame(svgr) %>%
  dplyr::select(QUAL, Caller, truth_matches) %>%
  dplyr::group_by(Caller, QUAL) %>%
  dplyr::summarise(
    calls=dplyr::n(),
    tp=sum(truth_matches > 0)) %>%
  dplyr::group_by(Caller) %>%
  dplyr::arrange(dplyr::desc(QUAL)) %>%
  dplyr::mutate(
    cum_tp=cumsum(tp),
    cum_n=cumsum(calls),
    cum_fp=cum_n - cum_tp,
    Precision=cum_tp / cum_n,
    Recall=cum_tp/length(wham_svgr))) +
  aes(x=Recall, y=Precision, colour=Caller) +
  geom_point() +
  geom_line() +
  theme_bw() +
  labs(title="NA12878 Delly/Manta/Melt/Wham vs Personalis")
```

## Visualising breakpoint pairs via circos plots

One way of visualising paired breakpoints is by circos plots.

Here, we use the plotting package ggbio which provides flexible track functions which bind with ggplot2 objects. It takes GRanges objects as input and supports circos plots. To plot structural variant breakpoints in a circos plot using ggbio, we need to first prepare the breakpoint GRanges. The function requires a special column, indicating the end of the link using GRanges format.

```{r circos}
suppressPackageStartupMessages(require(ggbio))

gr.circos <- delly_svgr[seqnames(delly_svgr) %in% seqlevels(biovizBase::hg19sub)]

seqlevels(gr.circos) <- seqlevels(biovizBase::hg19sub)

mcols(gr.circos)$to.gr <- granges(partner(gr.circos))

gr.circos <- na.omit(gr.circos)

#We can then plot the breakpoints against reference genomes.

ggbio() +
    circle(gr.circos, geom="link", linked.to="to.gr") +
    circle(biovizBase::hg19sub, geom='ideo', fill='gray70') +
    circle(biovizBase::hg19sub, geom='scale', size=2) +
    circle(biovizBase::hg19sub, geom='text', aes(label=seqnames), vjust=0, size=3)
```