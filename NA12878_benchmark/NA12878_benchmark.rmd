---
title: "Benchmarking Structural Variant Callers using NA12878 WGS reference"
author: 
  #David Fuh, <br/>
  #Summer Intern, <br/>
  #Garvan Institute of Medical Research, 
  #Kinghorn Centre for Clinical Genomics, <br/>
  #Sydney, NSW, Australia
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: yes
  html_document:
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
---
```{r setup, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(
                 fig.path   = 'figure/'
               #, cache.path = 'cache/'
               #, cache      = FALSE
               , dev        = 'png'
               , fig.align  = 'center'
               , fig.show   = 'hold'
               #, fig.width  = 8
               #, fig.height = 6
               #, out.width  = '.8\\linewidth'
               , par        = TRUE
               , echo       = TRUE ## toggle
               , warning    = FALSE
               , message    = FALSE
               )
```


# Packages
```{r Packages}
library(tidyverse)
library(paletteer)
library(patchwork)
library(GenomicRanges)
library(StructuralVariantAnnotation)
```

# Truth SV set of NA12878

## VCF file (hg38, Personalis & Spiral)
```{r READ IN Truth SV set NA12878}
setwd("~/GitRepo/summerproject2021/NA12878_benchmark/Maestro_scripts/VCF")

personalis_vcf <- readVcf("test_personalis_hg38.vcf")
spiral_vcf <- readVcf("test_spiral_hg38.vcf")

truth_vcf <- rbind(personalis_vcf, spiral_vcf)
```


# Benchmarking against the truth set

## BreakpointRanges
```{r caller_svgr generation}
setwd("~/GitRepo/summerproject2021/NA12878_benchmark/Maestro_scripts/VCF")
# full-sized
delly_vcf <- readVcf("NA12878.delly.vcf", "hg38")
delly_svgr <- breakpointRanges(delly_vcf)

manta_vcf <- readVcf("NA12878.manta.vcf", "hg38")
manta_svgr <- breakpointRanges(manta_vcf)

melt_vcf <- readVcf("NA12878.melt.vcf", "hg38")
melt_svgr <- breakpointRanges(melt_vcf)

wham_vcf <- readVcf("NA12878.wham.vcf", "hg38")
wham_svgr <- breakpointRanges(wham_vcf)

svaba_vcf <- readVcf("NA12878.svaba.vcf", "hg38")
svaba_svgr <- breakpointRanges(svaba_vcf)

# med-sized
med_delly_vcf <- readVcf("NA12878_med.delly.vcf", "hg38")
med_delly_svgr <- breakpointRanges(med_delly_vcf)

med_manta_vcf <- readVcf("NA12878_med.manta.vcf", "hg38")
med_manta_svgr <- breakpointRanges(med_manta_vcf)

med_melt_vcf <- readVcf("NA12878_med.melt.vcf", "hg38")
med_melt_svgr <- breakpointRanges(med_melt_vcf)

med_wham_vcf <- readVcf("NA12878_med.wham.vcf", "hg38")
med_wham_svgr <- breakpointRanges(med_wham_vcf)

med_svaba_vcf <- readVcf("NA12878_med.svaba.vcf", "hg38")
med_svaba_svgr <- breakpointRanges(med_svaba_vcf)

# small-sized
small_delly_vcf <- readVcf("NA12878_small.delly.vcf", "hg38")
small_delly_svgr <- breakpointRanges(small_delly_vcf)

small_manta_vcf <- readVcf("NA12878_small.manta.vcf", "hg38")
small_manta_svgr <- breakpointRanges(small_manta_vcf)

small_melt_vcf <- readVcf("NA12878_small.melt.vcf", "hg38")
small_melt_svgr <- breakpointRanges(small_melt_vcf)

small_wham_vcf <- readVcf("NA12878_small.wham.vcf", "hg38")
small_wham_svgr <- breakpointRanges(small_wham_vcf)

small_svaba_vcf <- readVcf("NA12878_small.svaba.vcf", "hg38")
small_svaba_svgr <- breakpointRanges(small_svaba_vcf)
```

## svgr filter
```{r svgr filter and dimensions}
# want Caller@elementMetadata$FILTER == "PASS" only
delly_svgr=subset(delly_svgr, delly_svgr@elementMetadata[, 5] == "PASS") ## 7816/39070
manta_svgr=subset(manta_svgr, manta_svgr@elementMetadata[, 5] == "PASS") ## 12080/14174 (SampleFT, MinQUAL, ...)
melt_svgr=subset(melt_svgr, melt_svgr@elementMetadata[, 5] == "PASS") ## 2006/3782 (looks mostly lowQUAL)
wham_svgr=subset(wham_svgr, wham_svgr@elementMetadata[, 5] == "PASS") ## 12788/12788 (looks ALL PASS)
svaba_svgr=subset(svaba_svgr, svaba_svgr@elementMetadata[, 5] == "PASS") ## 5804/5804 (ALL PASS)

# med
med_delly_svgr=subset(med_delly_svgr, med_delly_svgr@elementMetadata[, 5] == "PASS") ## 1544/?
med_manta_svgr=subset(med_manta_svgr, med_manta_svgr@elementMetadata[, 5] == "PASS") ## 474/?
med_melt_svgr=subset(med_melt_svgr, med_melt_svgr@elementMetadata[, 5] == "PASS") ## 904/?
med_wham_svgr=subset(med_wham_svgr, med_wham_svgr@elementMetadata[, 5] == "PASS") ## 2118/?
med_svaba_svgr=subset(med_svaba_svgr, med_svaba_svgr@elementMetadata[, 5] == "PASS") ## 1070/?

# small
small_delly_svgr=subset(small_delly_svgr, small_delly_svgr@elementMetadata[, 5] == "PASS") ## 372/?
small_manta_svgr=subset(small_manta_svgr, small_manta_svgr@elementMetadata[, 5] == "PASS") ## 238/?
small_melt_svgr=subset(small_melt_svgr, small_melt_svgr@elementMetadata[, 5] == "PASS") ## 196/?
small_wham_svgr=subset(small_wham_svgr, small_wham_svgr@elementMetadata[, 5] == "PASS") ## 548/?
small_svaba_svgr=subset(small_svaba_svgr, small_svaba_svgr@elementMetadata[, 5] == "PASS") ## 280/?
```

## Caller
```{r Assigning callers to svgr}
# assign caller info
delly_svgr$Caller <- "Delly"
manta_svgr$Caller <- "Manta"
melt_svgr$Caller <- "Melt"
wham_svgr$Caller <- "Wham"
svaba_svgr$Caller <- "SvABA"

# med
med_delly_svgr$Caller <- "Delly"
med_manta_svgr$Caller <- "Manta"
med_melt_svgr$Caller <- "Melt"
med_wham_svgr$Caller <- "Wham"
med_svaba_svgr$Caller <- "SvABA"

# small
small_delly_svgr$Caller <- "Delly"
small_manta_svgr$Caller <- "Manta"
small_melt_svgr$Caller <- "Melt"
small_wham_svgr$Caller <- "Wham"
small_svaba_svgr$Caller <- "SvABA"
```

## Coverage
```{r Assigning coverage to svgr}
# assign coverage info
delly_svgr$Cov <- "Large"
manta_svgr$Cov <- "Large"
melt_svgr$Cov <- "Large"
wham_svgr$Cov <- "Large"
svaba_svgr$Cov <- "Large"

# med
med_delly_svgr$Cov <- "Medium"
med_manta_svgr$Cov <- "Medium"
med_melt_svgr$Cov <- "Medium"
med_wham_svgr$Cov <- "Medium"
med_svaba_svgr$Cov <- "Medium"

# small
small_delly_svgr$Cov <- "Small"
small_manta_svgr$Cov <- "Small"
small_melt_svgr$Cov <- "Small"
small_wham_svgr$Cov <- "Small"
small_svaba_svgr$Cov <- "Small"
```

## truth_svgr

```{r Personalis & Spiral VCF}
truth_svgr <- breakpointRanges(truth_vcf)
```

```{r Precision X Recall plot <ORIGINAL>}
# Delineate each term
svgr <- c(delly_svgr, manta_svgr, melt_svgr, wham_svgr, svaba_svgr)

# delly: RP + SR
# manta: RP + SR + LA
# melt: 
# wham: 

svgr$truth_matches <- countBreakpointOverlaps(svgr, truth_svgr, 
                                              
                                              maxgap=100, sizemargin=0.25, ## explain
                                              
                                              restrictMarginToSizeMultiple=0.5, ## explain
                                              
                                              countOnlyBest=TRUE) ## do any of the callers (tend to) make duplicate calls?

# plot
# need to understand what each term/param means...
ggplot(as.data.frame(svgr) %>%
         dplyr::select(Caller, truth_matches) %>% ## QUAL mostly 0 & NA --- excluded
  dplyr::group_by(Caller) %>%
  
    dplyr::summarise(
    
      calls=dplyr::n(), ## number of calls for each caller that matches the truth
    
      tp=sum(truth_matches > 0)) %>% ## tp=true positive calls for each caller = sum(all non-0 tp calls for each caller)
  
    dplyr::group_by(Caller) %>%
  
    #dplyr::arrange(dplyr::desc(QUAL)) %>% ## QUAL doesn't work in our workflow, leave it
  
    dplyr::mutate(
    
      cum_tp=cumsum(tp),
    
      cum_n=cumsum(calls),
    
      cum_fp=cum_n - cum_tp,
    
      Precision=cum_tp / cum_n,
    
      Recall=cum_tp/length(truth_svgr)
      )
  ) +
  
aes(x=Recall, y=Precision, colour=Caller) +

  geom_point(size=2.5) +
  geom_line() +
  theme_bw() +
  labs(title="Delly/Manta/Melt/Wham/SvABA SV calls vs Truth Set \n (NA12878; Personalis & Spiral)")
```

```{r svgr med_svgr small_svgr generation}
svgr <- c(delly_svgr, manta_svgr, melt_svgr, wham_svgr, svaba_svgr)
med_svgr <- c(med_delly_svgr, med_manta_svgr, med_melt_svgr, med_wham_svgr, med_svaba_svgr)
small_svgr <- c(small_delly_svgr, small_manta_svgr, small_melt_svgr, small_wham_svgr, small_svaba_svgr)

svgr$truth_matches <- countBreakpointOverlaps(svgr, truth_svgr,
                                              maxgap=100, sizemargin=0.25, 
                                              restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)

med_svgr$truth_matches <- countBreakpointOverlaps(med_svgr, truth_svgr, 
                                                  maxgap=100, sizemargin=0.25, 
                                                  restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)

small_svgr$truth_matches <- countBreakpointOverlaps(small_svgr, truth_svgr, 
                                                    maxgap=100, sizemargin=0.25, 
                                                    restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)

ALL_svgr <- c(svgr, med_svgr, small_svgr)
```

```{r USE precision recall plot <ORIGINAL>}
# indiv. version

# delly: RP + SR
# manta: RP + SR + LA
# melt: 
# wham: 
# svaba:

# fine-tune each param for each caller later
# note that if any of the callers use different settings, must report as the previous
# vectroised version used "one-setting-for-all"
delly_svgr$truth_matches <- countBreakpointOverlaps(delly_svgr, 
                                              truth_svgr, 
                                              maxgap=100, sizemargin=0.25,
                                              restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
manta_svgr$truth_matches <- countBreakpointOverlaps(manta_svgr, 
                                              truth_svgr, 
                                              maxgap=100, sizemargin=0.25,
                                              restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
melt_svgr$truth_matches <- countBreakpointOverlaps(melt_svgr, 
                                             truth_svgr, 
                                             maxgap=100, sizemargin=0.25,
                                             restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
wham_svgr$truth_matches <- countBreakpointOverlaps(wham_svgr, 
                                             truth_svgr, 
                                             maxgap=100, sizemargin=0.25,
                                             restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
svaba_svgr$truth_matches <- countBreakpointOverlaps(svaba_svgr, 
                                             truth_svgr, 
                                             maxgap=100, sizemargin=0.25,
                                             restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)

# plot
# instead of using Papenfuss' Precision-Recall plot,
# let's understand the data (Caller$caller_matches) and work from there

# caller_matches is a single vector that has 0 == "no match with truth" or 1 == "matched with truth" for
# each SV call. So it retained *which* calls matched to the truth set 
# accroding to our parameters (double-check those params too)

# idea: group the big four into one so we can color by group / facet_wrap

svgr <- c(delly_svgr, manta_svgr, melt_svgr, wham_svgr, svaba_svgr)

# plot again
## overall recall?
ggplot(as.data.frame(svgr)) +
  aes(x=truth_matches, fill=Caller) +
  geom_bar(position = "dodge")

## recall rate
as.data.frame(svgr) %>%
         
         dplyr::select(Caller, truth_matches) %>% ## QUAL mostly 0 & NA --- excluded
  
         dplyr::group_by(Caller) %>%
  
    dplyr::summarise(
    
      calls=dplyr::n(), ## number of calls for each caller that matches the truth
    
      tp=sum(truth_matches > 0)) %>% ## tp=true positive calls for each caller = sum(all non-0 tp calls for each caller)
  
    dplyr::group_by(Caller) %>%
  
    dplyr::mutate(
    
      cum_tp=cumsum(tp),
    
      cum_n=cumsum(calls),
    
      cum_fp=cum_n - cum_tp,
    
      Precision=cum_tp / cum_n,
    
      Recall=cum_tp/length(truth_svgr)
      ) %>%

ggplot() +  
  geom_point(aes(x=Caller, y=Precision)) +
  geom_point(aes(x=Caller, y=Recall), shape = 21, fill="red", size=2.5) +
  ylab("Precision (black filled) & Recall (red filled)")
```


```{r USE precision recall plot <SUBSET BAR>}
# indiv. version
# plot
## count of breakpoint overlap (0, 1, 2) in each NA12878 sample vs the truth set 
L1 <- ggplot(as.data.frame(svgr)) +
  aes(x=truth_matches, fill=Caller) +
  geom_bar(position = "dodge") + 
  ggtitle("Large (~35X)") + ylab("Count") + xlab("") +
  theme_classic() + theme(legend.position = "none", plot.title = element_text(hjust = 0.5))

M1 <- ggplot(as.data.frame(med_svgr)) +
  aes(x=truth_matches, fill=Caller) +
  geom_bar(position = "dodge") + 
  ggtitle("Medium (~6X)") + ylab("") + xlab("n(Breakpoint overlap)") +
  theme_classic() + theme(legend.position = "none", plot.title = element_text(hjust = 0.5))

S1 <- ggplot(as.data.frame(small_svgr)) +
  aes(x=truth_matches, fill=Caller) +
  geom_bar(position = "dodge") + 
  ggtitle("Small (~1X)") + ylab("") + xlab("") + 
  theme_classic() +
  theme(plot.title = element_text(hjust = 0.5),
    legend.position = c(.95, .95),
    legend.justification = c("right", "top"),
    legend.box.just = "right",
    legend.margin = margin(6, 6, 6, 6))

grid.arrange(L1, M1, S1, nrow=1)
```


```{r USE precision recall plot <SUBSET POINTS>}
## recall rate
as.data.frame(svgr) %>%
         
         dplyr::select(Caller, truth_matches) %>% ## QUAL mostly 0 & NA --- excluded
  
         dplyr::group_by(Caller) %>%
  
    dplyr::summarise(
    
      calls=dplyr::n(), ## number of calls for each caller that matches the truth
    
      tp=sum(truth_matches > 0)) %>% ## tp=true positive calls for each caller = sum(all non-0 tp calls for each caller)
  
    dplyr::group_by(Caller) %>%
  
    dplyr::mutate(
    
      cum_tp=cumsum(tp),
    
      cum_n=cumsum(calls),
    
      cum_fp=cum_n - cum_tp,
    
      Precision=cum_tp / cum_n,
    
      Recall=cum_tp/length(truth_svgr)
      ) %>%

ggplot() +  
  geom_point(aes(x=Caller, y=Precision)) +
  geom_point(aes(x=Caller, y=Recall), shape = 21, fill="red", size=2.5) +
  ylab("Precision (black) & Recall (red) \n Large (mean ~35X)") -> L2

# med
as.data.frame(med_svgr) %>%
         
         dplyr::select(Caller, truth_matches) %>% ## QUAL mostly 0 & NA --- excluded
  
         dplyr::group_by(Caller) %>%
  
    dplyr::summarise(
    
      calls=dplyr::n(), ## number of calls for each caller that matches the truth
    
      tp=sum(truth_matches > 0)) %>% ## tp=true positive calls for each caller = sum(all non-0 tp calls for each caller)
  
    dplyr::group_by(Caller) %>%
  
    dplyr::mutate(
    
      cum_tp=cumsum(tp),
    
      cum_n=cumsum(calls),
    
      cum_fp=cum_n - cum_tp,
    
      Precision=cum_tp / cum_n,
    
      Recall=cum_tp/length(truth_svgr)
      ) %>%

ggplot() +  
  geom_point(aes(x=Caller, y=Precision)) +
  geom_point(aes(x=Caller, y=Recall), shape = 21, fill="red", size=2.5) +
  ylab("Medium (mean ~6X)") -> M2

# small
as.data.frame(small_svgr) %>%
         
         dplyr::select(Caller, truth_matches) %>% ## QUAL mostly 0 & NA --- excluded
  
         dplyr::group_by(Caller) %>%
  
    dplyr::summarise(
    
      calls=dplyr::n(), ## number of calls for each caller that matches the truth
    
      tp=sum(truth_matches > 0)) %>% ## tp=true positive calls for each caller = sum(all non-0 tp calls for each caller)
  
    dplyr::group_by(Caller) %>%
  
    dplyr::mutate(
    
      cum_tp=cumsum(tp),
    
      cum_n=cumsum(calls),
    
      cum_fp=cum_n - cum_tp,
    
      Precision=cum_tp / cum_n,
    
      Recall=cum_tp/length(truth_svgr)
      ) %>%

ggplot() +  
  geom_point(aes(x=Caller, y=Precision)) +
  geom_point(aes(x=Caller, y=Recall), shape = 21, fill="red", size=2.5) +
  ylab("Small (mean ~1X)") -> S2

L2 + M2 + S2
```

```{r Synthesis of three cov levels P/R}
# extract the numeric info instead to simplify things
# we need a new data frame
test <- data.frame()
# extract the key variables
# we need:
# Precision for each caller, for each coverage level
# Recall rate for each caller, and for each coverage

## large
test_large = as.data.frame(svgr) %>%
         
         dplyr::select(Caller, truth_matches) %>% ## QUAL mostly 0 & NA --- excluded
  
         dplyr::group_by(Caller) %>%
  
    dplyr::summarise(
    
      calls=dplyr::n(), ## number of calls for each caller that matches the truth
    
      tp=sum(truth_matches > 0)) %>% ## tp=true positive calls for each caller = sum(all non-0 tp calls for each caller)
  
    dplyr::group_by(Caller) %>%
  
    dplyr::mutate(
    
      cum_tp=cumsum(tp),
    
      cum_n=cumsum(calls),
    
      cum_fp=cum_n - cum_tp,
    
      Precision=cum_tp / cum_n,
    
      Recall=cum_tp/length(truth_svgr)
      )
test_large$Cov <- "Large"

## medium
test_medium = as.data.frame(med_svgr) %>%
         dplyr::select(Caller, truth_matches) %>%
         dplyr::group_by(Caller) %>%
    dplyr::summarise(
      calls=dplyr::n(), ## number of calls for each caller that matches the truth
      tp=sum(truth_matches > 0)) %>% ## tp=true positive calls for each caller = sum(all non-0 tp calls for each caller)
  
    dplyr::group_by(Caller) %>%
  
    dplyr::mutate(
      cum_tp=cumsum(tp),
      cum_n=cumsum(calls),
      cum_fp=cum_n - cum_tp,
    
      Precision=cum_tp / cum_n,
      Recall=cum_tp/length(truth_svgr)
      )
test_medium$Cov <- "Medium"

## small
test_small = as.data.frame(small_svgr) %>%
         dplyr::select(Caller, truth_matches) %>%
         dplyr::group_by(Caller) %>%
    dplyr::summarise(
      calls=dplyr::n(), ## number of calls for each caller that matches the truth
      tp=sum(truth_matches > 0)) %>% ## tp=true positive calls for each caller = sum(all non-0 tp calls for each caller)
  
    dplyr::group_by(Caller) %>%
  
    dplyr::mutate(
      cum_tp=cumsum(tp),
      cum_n=cumsum(calls),
      cum_fp=cum_n - cum_tp,
    
      Precision=cum_tp / cum_n,
      Recall=cum_tp/length(truth_svgr)
      )
test_small$Cov <- "Small"

# full join
test <- plyr::join(test_large, test_medium, type = "full") %>% plyr::join(., test_small, type = "full")
```

```{r}
# plot
ggplot(test) +
  geom_point(aes(x=Caller, y=Precision)) +
  geom_point(aes(x=Caller, y=Recall), shape=25, fill="red", size=2.5) +
  facet_wrap(~Cov) +
  ylab("Precision (black dot) & Recall (Red triangle)")
```


```{r}
# want to know more about the non-zero recalls in NA12878 small subset
# to do that, we need support read info
# use the script "Add_support_read_info.R"

# output files: caller.bpr x5 and caller_vcf x5

supported_svgr=c(delly.bpr, manta.bpr, svaba.bpr, melt.bpr, wham.bpr)
```












## CONSENSUS SCREENING: Using countBreakpointOverlaps() to find matching calls between callers

countBreakpointOverlaps(Caller1_svgr, Caller2_svgr) compares the SV calls between two callers based on a given set of criteria for breakpoint resolution between two approximate calls, and returns a vector of (0...1...) 's for every call position. In which,
0 = FALSE (no match) and 1 = TRUE (matches).

We can exploit this function to find which calls were consistent between any two, or more, callers, of the five callers we are benchmarking.

We will start as an example with the full-sized file from NA12878.


```{r test}
# test: match delly/wham calls
# both callers call from relatively large SVs to small SVs

head(countBreakpointOverlaps(delly_svgr, manta_svgr), 100)
```

What to do with the resultant object?

```{r test}
delly_svgr$mantamatch <- countBreakpointOverlaps(delly_svgr, manta_svgr, 
                                                 sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)

dXm <- delly_svgr[delly_svgr$mantamatch==1] ## reads: "of those calls who matches with manta, subset to this df
```

The resultant subset (a GR) can be used for many purposes.


```{r Ten pairwise comparisons}
# we will use consistent criteria for breakpoint resolution as before

# we will do all 10 pair-wise comparisons together
# C(5,2) = 10 comparisons
# each svgr stores comparison with other callers

# first, we use wham (n=12788, largest of five) as the standard
delly_svgr$whammatch <- countBreakpointOverlaps(delly_svgr, wham_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
manta_svgr$whammatch <- countBreakpointOverlaps(manta_svgr, wham_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
melt_svgr$whammatch <- countBreakpointOverlaps(melt_svgr, wham_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
svaba_svgr$whammatch <- countBreakpointOverlaps(svaba_svgr, wham_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
# compare to manta (n=12080)
delly_svgr$mantamatch <- countBreakpointOverlaps(delly_svgr, manta_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
wham_svgr$mantamatch <- countBreakpointOverlaps(wham_svgr, manta_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
melt_svgr$mantamatch <- countBreakpointOverlaps(melt_svgr, manta_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
svaba_svgr$mantamatch <- countBreakpointOverlaps(svaba_svgr, manta_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
# to delly (n=7816)
wham_svgr$dellymatch <- countBreakpointOverlaps(wham_svgr, delly_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
manta_svgr$dellymatch <- countBreakpointOverlaps(manta_svgr, delly_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
melt_svgr$dellymatch <- countBreakpointOverlaps(melt_svgr, delly_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
svaba_svgr$dellymatch <- countBreakpointOverlaps(svaba_svgr, delly_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
# to svaba (n=5804)
delly_svgr$svabamatch <- countBreakpointOverlaps(delly_svgr, svaba_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
manta_svgr$svabamatch <- countBreakpointOverlaps(manta_svgr, svaba_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
melt_svgr$svabamatch <- countBreakpointOverlaps(melt_svgr, svaba_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
wham_svgr$svabamatch <- countBreakpointOverlaps(wham_svgr, svaba_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
# to melt (n=2006)
delly_svgr$meltmatch <- countBreakpointOverlaps(delly_svgr, melt_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
manta_svgr$meltmatch <- countBreakpointOverlaps(manta_svgr, melt_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
wham_svgr$meltmatch <- countBreakpointOverlaps(wham_svgr, melt_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
svaba_svgr$meltmatch <- countBreakpointOverlaps(svaba_svgr, melt_svgr, 
                                       sizemargin=0.25, restrictMarginToSizeMultiple=0.5, countOnlyBest=TRUE)
```


```{r Consensus list}
# consensus list: comparisons of comparisons
# start largest, then small
whamMantaDelly=wham_svgr[wham_svgr$mantamatch==1 & wham_svgr$dellymatch==1] ## n=1420
# compare with the dplyr version
whamMantaDelly = subset(wham_svgr, dellymatch==1 & mantamatch==1) ## also n=1420

whamMantaDellySvaba=whamMantaDelly[whamMantaDelly$svabamatch==1] ## n=1070

consensus=whamMantaDellySvaba[whamMantaDellySvaba$meltmatch==1] ## n=0 (!)
## does order matter here? why?
consensus = subset(whamMantaDellySvaba, meltmatch==1) ## n=0

consensus = subset(wham_svgr, mantamatch==1 & dellymatch==1 & meltmatch==1 & svabamatch==1) ## still n=0
```


```{r Annotate with caller number}
# explain whether the following approach is valid or not and why:
svgr <- c(delly_svgr, manta_svgr, melt_svgr, wham_svgr, svaba_svgr)

## why does dellymatch give NA?
svgr$dellymatch ## NA
svgr$mantamatch ## looks normal

# if a variant call is called by k out of the five callers,
# let a new column $numCallers = k for that row
svgr$numCallers
```



## Visualising breakpoint pairs via circos plots

One way of visualising paired breakpoints is by circos plots.

Here, we use the plotting package ggbio which provides flexible track functions which bind with ggplot2 objects. It takes GRanges objects as input and supports circos plots. To plot structural variant breakpoints in a circos plot using ggbio, we need to first prepare the breakpoint GRanges. The function requires a special column, indicating the end of the link using GRanges format.

```{r circos setup subset, eval=FALSE, include=FALSE}
# test on subset first as the original took very long
setwd("~/GitRepo/summerproject2021/NA12878_benchmark/Maestro_scripts/VCF")

small_wham_vcf <- readVcf("NA12878_small.wham.vcf", "hg38")
small_wham_svgr <- breakpointRanges(small_wham_vcf)

chrom <- c("chr1", "chr2", "chr3", "chr4", "chr5", "chr6", "chr7", "chr8", "chr9", "chr10", "chr11", "chr12",
           "chr13", "chr14", "chr15", "chr16", "chr17", "chr18", "chr19", "chr20", "chr21", "chr22", "chrX")

# or simply,
chrom <- paste0("chr", 1:22) %>% append(., "chrX")

#
gr.test <- small_wham_svgr[seqnames(small_wham_svgr) %in% chrom]

seqlevels(gr.test) <- chrom
#
mcols(gr.test)$to.gr <- granges(partner(gr.test))


#We can then plot the breakpoints against reference genomes.

ggbio() +
    circle(gr.test, geom="link", linked.to="to.gr") +
    circle(1:22, geom='ideo', fill='gray70') +
    circle(1:22, geom='scale', size=2) +
    circle(1:22, geom='text', aes(label=1:22), vjust=0, size=3)
```


### use package "circlize"
```{r, eval=FALSE, include=FALSE}
library(circlize)
# extract chr end points
chrRanges=head(as.vector(biovizBase::ideo@ranges), n=24)
chr.match=regexpr("[0-9]{6,}", chrRanges)
chr.end=regmatches(chrRanges, chr.match)
# start circos
circos.clear()
circos.initialize(factors=chrom, 
                  xlim=matrix(c(rep(1, 24), 
                                chr.end), 
                              ncol=2))

circos.clear()
col_text <- "grey40"
circos.par("track.height"=0.8, gap.degree=5, cell.padding=c(0, 0, 0, 0))
circos.initialize(factors=ref$V1, xlim=matrix(c(rep(0, 3), ref$V2), ncol=2))

# genomes
circos.track(ylim=c(0, 1), panel.fun=function(x, y) {
chr=seqnames(small_wham_svgr)
xlim=CELL_META$xlim
ylim=CELL_META$ylim
circos.text(mean(xlim), mean(ylim), chr, cex=0.5, col=col_text, 
facing="bending.inside", niceFacing=TRUE)
}, bg.col="grey90", bg.border=F, track.height=0.06)
```

