---
title: "Benchmarking NA12878 SVs by different callers"
edition: "Maestro"
date: "Jan 13, 2022"
output: html_notebook
---
# Version updates

This is version "Maestro 1.0". 

We moved relevant codes from the old NA12878_benchmark.rmd to this notebook, and aim to use the maestro file for all analyses. (See maestro_generation.R)


# Prerequisites

For pre-processing files, you will need:

  - All NA12878-derived (against GRCh38) VCF outputs from callers {Delly, Manta, Melt, Wham, SvABA}, from the workflow GATK-SV.
  - Note that SvABA output was from its own workflow independent of GATK-SV.


You will then need to process these files via AnnotSV (cf. ReadME). The settings are described on ReadME.


For the R scripts for processing these VCF files, you will need:

  - maestro_generation_full.R (For Annotation_mode == "full")
  - maestro_generation_split.R (For Annotation_mode == "split")


Finally, to run this notebook, you will need:

  - benchmark.full (Data frame containing AnnotSV products from all callers in all subsets of NA12878, using "full" mode)
  - benchmark.split (Same, except using "split" mode)


To start the workflow, go to #Main.



# Filtering and processing notes:

    1) FILTER == "PASS" (Pre-filtered in maestro scripts)
    2) SV_length != 0 (Filtered here)
    
There was an experiment in the SV length section where we restricted -20,000 <= SV_length <= 20,000 (bp).
It was called "sizedSVs".





# Working notes


- See tabs with [ONGOING] in the header for items currently still being worked on. They include:

    1. Creating a SV aggregation workflow with relaxed criteria
    2. Remaining items in #TO-DO


## TO-DO

- **TODO**: Find gold standard NA12878 SV call set ("truth set")
- **TODO**: Include supporting reads info


## Questions to be solved

Highlight "> Q" in the document to look for unanswered questions.

    1. Does massively-sized SV calls confound any of our results here? Why or why not?
    
    2. Why were there calls made on the Y chromosome, when NA12878 is known to be female?
    
    > Note that Manta didn't call any variants on Y --- it's other callers that have annotated calls on Y. Good to note!




# Introduction

See ReadME.md.

## Heterogeneity between caller outputs

It is important to note that the VCF outputs produced not only different results, but different variables among the five callers.

I am not sure about the VCF files yet (did not have time to go through them raw), but for the annotated TSVs I'm working with, I've noticed: 

    1. the SvABA annotated output contains fully completed QUAL, but for Delly QUAL is mostly NA;
    2. the SvABA (I think we used svaba.sv.vcf for sure...double check) output has SV_length = 1 for all calls (!!!)
    3. the SvABA VCF has undergone import processing (see Svaba_output_processing.R)
    4. the Melt calls were much smaller (-500 ~ 6,500 bp) than Delly, Manta, Wham (mean SV_length ~ 3mb)





# Main 

## Data import
```{r}
benchmark.full <- read.csv("Maestro_scripts/maestro.full.csv")
benchmark.split <- read.csv("Maestro_scripts/maestro.split.csv")
```


## Data subsetting & processing

### 1. FILTER == "PASS"
Make sure QC passed before running the rest of the analysis:
```{r}
# always double-check
table(as.factor(benchmark.full$FILTER))
table(as.factor(benchmark.split$FILTER))
```

You should only see one level in the two data frames tested --- "PASS".



### 2. Reordering chromosome labels
```{r}
# Reordering SV_chrom axis
benchmark.full$SV_chrom <- factor(benchmark.full$SV_chrom, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "X", "Y", "M"))

benchmark.split$SV_chrom <- factor(benchmark.split$SV_chrom, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "X", "Y", "M"))
```


### 3. Coverage is to be aware of

> NB: Both benchmark.full and benchmark.split contain overlayed information from the small, medium, and large set. As a result, it creates spikes that are artefacts which confounds the results if not removed. We will "filter the real data" back to a clean data frame in which only those calls from the "Large" NA12878 set is used.

Note that as a result, we will be using large.* data frames for most of the analyses. Only when Coverage data is used we will employ benchmark.* data frames.

Due to the large size of the benchmark.* data frames, you can remove them if you're not running the coverage chunks.


```{r}
# main data frames we will be using
large.full <- filter(benchmark.full, Coverage == "Large")
large.split <- filter(benchmark.split, Coverage == "Large")
```



### 4. SV length: SvABA has BND calls only and has, for some reason, size=0 (even though it should be 1)

We further clean up the data frame:
```{r}
# AM = full
dim(large.full)
# There shouldn't be any SV calls of size 0
large.full <- large.full %>% filter(SV_length != 0) 
dim(large.full)
```

> Over 10,000 entries (over 40% of original calls) in AM=full had SV_length = 0. These were the SvABA calls

Note that we kept the calls with SV_length = NA, as some calls may still be valid even with missing SV_length.

```{r}
# AM = split
dim(large.split)
# There shouldn't be any SV calls of size 0
large.split <- large.split %>% filter(SV_length != 0) 
dim(large.split)
```

Guess what...these removed files contain no information on SvABA.

So for analyses requiring SvABA to be included, we will run them on a separate notebook.




## Packages

```{r message=FALSE}
library(tidyverse)
library(ggthemes)
library(ggforce)
library(cowplot)
library(vegan)
library(egg)
library(viridis)
library(wesanderson) ## optional
library(RColorBrewer)
```


## Analysis

## Section I. [w/o reference] Caller against Caller set {Delly, Manta, SvABA, Wham, Melt}.

### 0. Coverage as a measure of call confidence

> The read count is used as a proxy for quality when quality score is not reported. Some callers report all calls and stratify them into pass (which can be considered as high confidence) and non-pass (low confidence), while others report only pass calls.^[1]


In this case, all of our callers benchmarked reported each call with PASS/lowQUAL/...other measures, as described previously, we filtered those only reported with the "PASS" status.

The read count / coverage factors are therefore considered uniform in the following analyses.

NB: "Coverage" was assigned as a new categorical variable to represent "from which genome subset of NA12878" the call was made. There are three levels: "Small", "Med", and "Large" (the full set).



### 1. SV call location across NA12878


> Q: Explain recordings in the Y chromosome.




```{r}
table(benchmark.full$SV_chrom)
table(large.full$SV_chrom)
```


#### 1-1. SV location by callers: OR IS IT?

```{r message=FALSE}
# THIS IS AN INCORRECT GRAPH
ggplot(benchmark.full, aes(x = SV_chrom, fill=Caller)) +
    geom_bar() + #scale_y_log10() +
    theme_bw() + theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust = 1.2)) +
    labs(x="Chromosome", y="count") + 
    ggtitle("SV location by different callers in NA12878 using AnnotSV, AM = full \n --- MISREPRESENTATION")
```

This is inaccurate --- if you try to explain the spike in Chr#20 (it's not any bigger physically), you'll see it's due to the fact we've aggregated the data set (small, med, large) altogether. The resultant file has over-condensation on certain chromosomes.

This is evident when we split the counts apart by their Coverage column:

#### 1-2. SV location by coverage (small, medium, large)

```{r message=FALSE}
benchmark.full %>%
  group_by(Coverage, SV_chrom) %>%
    summarise(mean.A = mean(n()),
    sd.A = sd(n()),
    SE.A = sd(n())/sqrt(n())) %>%

  ggplot(aes(SV_chrom, mean.A, fill=Coverage)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    
    geom_errorbar(aes(ymin = mean.A-SE.A, ymax = mean.A+SE.A), width = 0.3, position = position_dodge(0.9)) +
    ylab("Count") + xlab("Chromosome") +
    theme_classic()

ggsave2(filename = "SV_location_by_coverage_NA12878.png")
```

We see that the pink column is the true graph we wanted in Section 1-1. We will generate it by

#### 1-3. SV location by callers

```{r}
large.full %>%

ggplot(aes(x = SV_chrom, fill=Caller)) +
    geom_bar() +
    theme_bw() +
    labs(x="Chromosome", y="count") + 
    ggtitle("SV location by different callers in NA12878 using AnnotSV, AM=full")

ggsave2(filename = "SV_location_by_caller_NA12878_full.png")
```




### 2. Types of Structural Variants

#### 2-1. SV tpye between callers (excluding SvABA due to NA length*)

*We know all SvABA read-in's contain SV size = 1, type == "BND" for all calls.

```{r message=FALSE}
sample_size = large.full %>% group_by(SV_type) %>% summarize(num=n())

large.full %>%
  left_join(sample_size) %>%
  mutate(svtype = paste0(SV_type, "\n (n=", num, ")")) %>%

ggplot(aes(x = svtype, fill=Caller)) +
    geom_bar() + #scale_y_log10() +
    theme_bw() +
    labs(x="Type of SV", y="count") +
    ggtitle("Types of structural variants detected by different callers in NA12878")

ggsave2("SV_type_by_caller_NA12878_full.png")

rm("sample_size")
```

Note that:

    1. ALU, LINE1 (sometimes referred to as L1) and SVA (SINE-R, VNTR and Alu composite) are all considered MEIs (Mobile element *insersion*s), and in our call set were all produced by [Melt].
    
    2. [SvABA] only counts BNDs in the entire call set, and has only SV_length = 1 (Even if we used strictly svaba.sv.vcf!)



```{r eval=FALSE, warning=FALSE}
# svaba.tst is from GR_script.R
# SV type
ggplot(svaba.tst) + aes(SV_type) + geom_histogram(stat = "count")
# SV length
SV_length.svaba <- svaba.tst$SV_end - svaba.tst$SV_start
plot(SV_length.svaba)
```


#### 2-2. [OPTIONAL] Synthesising SV types to four simple SV events: {DEL, DUP, INS/MEI, INV}











#### 2-3. SV types vs coverage level (Small, Medium, Large subset reads of NA12878)

```{r message=FALSE}
benchmark.full %>%
  group_by(Coverage, SV_type) %>%
    summarise(mean.A = mean(n()),
    sd.A = sd(n()),
    SE.A = sd(n())/sqrt(n())) %>%
# Bar plot
  ggplot(aes(SV_type, mean.A, fill=Coverage)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    
    geom_text(aes(label = paste(round(mean.A, 0))), position = position_dodge(0.7), 
              vjust =0.0, hjust=0.6, size = 3.5) + ## labels mean data on top of bar
    
    geom_errorbar(aes(ymin = mean.A-SE.A, ymax = mean.A+SE.A), width = 0.3, position = position_dodge(0.9)) +
    ylab("Count") + xlab("SV Type") +
    theme_classic() +
    ggtitle("SV types detected by various callers in NA12878")

ggsave2("SV_type_by_caller_and_coverage_NA12878.png")
```





### 3. Size and length of Structural Variants in the call set

#### 3-1. SV length by caller, no restriction
```{r}
boxplot(data = large.full, SV_length ~ Caller)
```

```{r}
boxplot(log10(abs(large.full$SV_length)) ~ large.full$Caller)
```


```{r}
# a nicer-looking alternative to the above plot
large.full %>% filter(!is.na(SV_length)) %>%
  filter(SV_length != 0) %>%
  mutate(SV_length = abs(SV_length)) %>%
  
  ggplot(aes(x=Caller, y=SV_length, fill=Caller)) + geom_boxplot() + 
  theme_bw() + 
  scale_y_log10(breaks=c(10, 10^2, 10^3, 10^4, 10^5, 10^6, 10^7, 10^8), 
                labels=c("10 bp", "100 bp", "1 kb", "10 kb", "100 kb", "1 Mb", "10 Mb", "100 Mb")) +
  
  ylab("SV size (log-scaled)") + xlab("") + 
  ggtitle("SV size by callers in NA12878, excluding SvABA (l=1)")

ggsave2("SV_size_by_callers_NA12878_box.png")
```


First look: 


- Delly has fewer outliers --- or were they filtered out during data prep stage?
- Manta has large outlier group (very large-sized SV calls) but otherwise more precise than the other two (?)
- Melt calls specifically ALU/SVs of size < 1kb
- Wham has considerable variance and overall similar call-range (in size) to Manta
- SvABA is excluded as it's poorly annotated. Note that SV size = 1 for all svaba.sv.vcf calls. (WHY?)



```{r}
# interested in knowing the SV length distribution excluding SvABA (only BND, length=1) and Melt (small SV, mean=~280 bp)
filter(large.full, !is.na(SV_length)) %>% ## report these later
  filter(SV_length != 0) %>% ## why do these even exist as calls? lol
  mutate(SV_length = abs(SV_length)) %>% ## BE CAREFUL: log takes only X > 0 !! 
  filter(., Caller %in% c("Delly", "Manta", "Wham")) %>%
  
  ggplot(.) + aes(SV_length, fill=Caller) + geom_density() +
  #scale_fill_brewer(palette = "Set2") +
  scale_x_log10(breaks=c(10, 10^2, 10^3, 10^4, 10^5, 10^6, 10^7, 10^8), 
                labels=c("10 bp", "100 bp", "1 kb", "10 kb", "100 kb", "1 Mb", "10 Mb", "100 Mb")) +
  theme_classic() +
  xlab("SV size (log-scaled)") + ylab("Density")

ggsave2("Dentsity_SV_size_callers_exc_Melt_SvABA_NA12878.png")
```




Now, we look at whether to limit our SV call set by size or not:


#### Limiting SV call size: **noNAlengthSV** excludes 0s and NA, **sizedSVs** are *those* between [-20k, 20k]
```{r message=FALSE}
# clean NA/0 entries first
large.full %>% filter(!is.na(SV_length)) %>%
  filter(SV_length != 0) -> noNAlengthSV

# limit SV length range
sizedSVs <- noNAlengthSV %>% filter(between(SV_length, -20000, 20000)) # next try +-100k
```


```{r message=FALSE}
# check distribution again
boxplot(data = sizedSVs, SV_length ~ Caller)

# apply transform
boxplot(log10(abs(sizedSVs$SV_length)) ~ sizedSVs$Caller)

# suspect Melt calls a lot of small SVs (ALU, LINE1, SVA) --- cf. Chunk/Figure 2-1
#view(filter(sizedSVs, Caller == "Melt")$SV_length) ## better view than table here

sizedSVs %>% filter(Caller == "Melt") %>%
  ggplot(aes(x=SV_length)) + geom_histogram(binwidth = 25) + 
  ggtitle("Length of SV called by Melt (limit size < 20 kb) in NA12878") +
  facet_zoom(xlim = c(0, 500)) ## zoom in on ~ 500 bp region

ggsave2("SV_size_under_20kb_Melt_NA12878_zoom.png")
# in fact, those called by Melt of size < 20kb are mostly in (mean) size 280 bp!
```


```{r message=FALSE}
# interested in trying to see other callers as well
## Delly
sizedSVs %>% filter(Caller == "Delly") %>%
  ggplot(aes(x=SV_length)) + geom_histogram() + 
  ggtitle("SV called by Delly (< 20 kb), NA12878")
  #+ facet_zoom(xlim = c(0, 500))

## Manta
sizedSVs %>% filter(Caller == "Manta") %>%
  ggplot(aes(x=SV_length)) + geom_histogram() + 
  ggtitle("SV called by Manta (< 20 kb), NA12878")

## Wham
sizedSVs %>% filter(Caller == "Wham") %>%
  ggplot(aes(x=SV_length)) + geom_histogram() + 
  ggtitle("SV called by Wham (< 20 kb), NA12878")

## wait..just overlay
sizedSVs %>% 
  ggplot(.) + aes(x=SV_length, fill=Caller) + geom_histogram(binwidth = 15) + 
  ggtitle("SV called by Delly, Manta, Wham, Melt (< 20 kb), NA12878") + theme_classic() +
  xlab("SV size") +
  facet_zoom(xlim = c(-1500, 1500)) #+ facet_zoom(xlim = c(-500,500))

ggsave2("SV_size_count_by_caller_20kb_NA12878.png")
```


Seems like when putting SvABA aside, Melt has very high precision in calling smaller SVs --- especially those of size ~280 bp.

> Obviously --- Melt was designed to call variants like ALU (from e.g. AluY) and other transposible elements like LINE, which typically span around < 1 kb.



On the other hand, Delly, Manta, and Wham seems to call much larger variants (even when prefiltered to size < 20 kb). So far it's consistent with our previous analysis:


#### 3-2. SV length by caller, under 20 kb

```{r}
# using sized SV set
sizedSVs %>%
  
  ggplot(aes(x=Caller, y=abs(SV_length), fill=Caller)) + geom_boxplot() + scale_y_log10() +
  theme_bw() + ylab("SV size") + xlab("") + ggtitle("SV size (< 20 kb) by callers in NA12878")

ggsave2("SV_size_under_20kb_by_callers_NA12878.png")
```


Let's dig further:

#### 3-3. SV length across chromosomes, marked by Caller
```{r message=FALSE}
## original (unlimited) call set
ggplot(noNAlengthSV, 
       aes(SV_chrom, SV_length, color=Caller)) + geom_point() + ylab("SV size")
```

```{r message=FALSE}
# log version
noNAlengthSV %>% mutate(SV_length = abs(SV_length)) %>%
  
  ggplot(.) + aes(SV_chrom, SV_length, color=Caller) + geom_point() +
  
  # try to apply convex hulls here...or similar models
  
  scale_y_log10(breaks=c(10, 10^2, 10^3, 10^4, 10^5, 10^6, 10^7, 10^8), 
                labels=c("10 bp", "100 bp", "1 kb", "10 kb", "100 kb", "1 Mb", "10 Mb", "100 Mb")) +
  
  xlab("Chromosome") + ylab("SV size") + theme_few()

ggsave2("SV_size_by_caller_across_chromosomes.png")
```


```{r message=FALSE}
## try to sample down a bit to avoid overpopulation confounding
# (n_Wham = 5482, n_Manta = 5391, n_Delly = 3165, n_Melt = 1003)

noNAlengthSV %>% mutate(SV_length = abs(SV_length)) %>% .[sample(nrow(.), 6000), ] %>%
  
  ggplot() + aes(SV_chrom, SV_length, color=Caller) + geom_point() +
  
  # try to apply convex hulls here...or similar models
  
  scale_y_log10(breaks=c(10, 10^2, 10^3, 10^4, 10^5, 10^6, 10^7, 10^8), 
                labels=c("10 bp", "100 bp", "1 kb", "10 kb", "100 kb", "1 Mb", "10 Mb", "100 Mb")) +
  
  xlab("Chromosome") + ylab("SV size") + theme_few() +
  
  ggtitle("sampled at n=6000 out of 15041 calls")

ggsave2("SV_size_by_caller_across_chromosomes_subsampled.png")
```



```{r message=FALSE}
## sized SVs
ggplot(sizedSVs, 
       aes(SV_chrom, SV_length, color=Caller)) + geom_point() + ylab("SV length (< 20kb)") + xlab("Chromosome") +
  theme_classic()

ggsave2("SV_length_under_20kb_by_caller_across_chromosomes_NA12878.png")
```


```{r message=FALSE}
# I want to highlight only those calls that exceed, say, 10 kb (NOTE THAT THE DATA FRAME WE USED ARE LIMITED TO < 20 KB)
ggplot(sizedSVs) + aes(SV_chrom, SV_length, color=Caller) + 
  
  geom_point(color = ifelse(abs(sizedSVs$SV_length) < 10000, "grey50", "red")) + 
  
  ylab("SV length (< 20kb)") + xlab("Chromosome") +
  
  facet_wrap( ~Caller, nrow = 1) + theme_bw() + #theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust = 1.2)) +
  
  scale_x_discrete(breaks = as.numeric(levels(sizedSVs$SV_chrom))[c(TRUE, rep(FALSE, 3))])

ggsave2("SV_length_under_20kb_by_caller_across_chromosomes_NA12878_wrapped.png")
```

#### 3-4. ANOVA: SV length by caller
```{r}
aov(data=sizedSVs, SV_length ~ Caller) %>%
  summary()

plot(aov(data=sizedSVs, SV_length ~ Caller))
```


```{r}
# log transform to accomodate the large SV size span

# ANOVA
sizedSVs %>% mutate(SV_length = log10(abs(SV_length))) %>%
  
  aov(data=., SV_length ~ Caller) -> SV.size.aov

summary(SV.size.aov)

# Check Q-Q plots
plot(SV.size.aov)
```


#### 3-5. SV length vs SV type 


```{r warning=FALSE, message=FALSE}
# want to create a walking line graph of each SV type, X = SV length, Y = count (log each axis)
#large.full %>% group_by(SV_type) %>% summarize(num=n()) %>%

ggplot(large.full) + aes(x=abs(SV_length), color = SV_type) + 
  geom_line(aes(fill=..count..), stat="bin", size = 1.05) +
  theme_classic() + 
  ylab("Count") +
  scale_color_brewer(name = "SV type", palette = "Set2") +
  scale_x_log10(name = "SV size (log-scaled)", 
                breaks = c(1, 20, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8), 
                label = c("1 bp", "20 bp", "100 bp", "1 kb", "10 kb", "100 kb", "1 Mb", "10 Mb", "100 Mb"))

ggsave2("SV_length_of_each_type_line_graph_NA12878.png")
```

We already know that SVA only has 35 counts and LINE1 has only 105 --- while ALU has > 800 counts and other types well over 1K counts.

```{r warning=FALSE, message=FALSE}
# if we're only interested in DEL/DUP/INV/INS/ALU**
large.full %>% filter(!(SV_type %in% c("SVA", "LINE1"))) %>%

ggplot(.) + aes(x=abs(SV_length), color = SV_type) + 
  geom_line(aes(fill=..count..), stat="bin", size = 1.05) +
  scale_color_brewer(name = "SV type", palette = "Set2") +
  theme_classic() + 
  ylab("Count") +
  scale_x_log10(name = "SV size (log-scaled)", 
                breaks = c(1, 20, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8), 
                label = c("1 bp", "20 bp", "100 bp", "1 kb", "10 kb", "100 kb", "1 Mb", "10 Mb", "100 Mb"))

ggsave2("SV_length_of_each_type_exc_SVA_L1_NA12878.png")
```



### 4. Number of variants detected by all methods

```{r eval=FALSE}
table(as.factor(large.full$Caller)) ## SV size = NA included, size = 0 excluded
```

We want to know: Are any of these calls made by multiple callers? We take the following approach.

> Let %CI == "a set standard" (e.g. 0.1% of SV_length), then define two given SV calls match if and only if:


      start_A is within [start_B +- %CI] 
      
      && 
      
      end_A is within [end_B +- %CI]
      
> ... and we can use the original workflow to aggregate the Callers for same SV calls (as defined above).


#### [ONGOING] Use data.table
#### [ONGOING] Use GenomicRanges::findOverlap













### 5. ACMG class of variants

```{r}
# first, see the distribution of ACMG class in annotated data
table(large.full$ACMG_class)
table(large.split$ACMG_class) ## any difference?
```

Note that for benchmark.full, the NA rows did not show up here.


#### AM == "Full"

```{r message=FALSE}
sample_size = large.full %>% group_by(ACMG_class) %>% summarize(num=n())

large.full %>%
  left_join(sample_size) %>%
  mutate(ACMG.class = paste0(ACMG_class, "\n (n=", num, ")")) %>%

ggplot(aes(x = ACMG.class, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="ACMG class", y="Count") + 
    scale_fill_discrete(name = "SV type") +
    ggtitle("ACMG class and SV type detected in NA12878, AM=full")

ggsave2("ACMG_class_and_SV_type_NA12878_AM_full.png")

rm("sample_size")
```

Try removing ACMG = NA entries:

```{r message=FALSE}
filter(large.full, !is.na(ACMG_class)) %>%

ggplot(aes(x = ACMG_class, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="ACMG class", y="count") +
    scale_fill_discrete(name = "SV type") +
    ggtitle("ACMG class and SV type in NA12878, excluding NA. AM=full")

ggsave2("ACMG_class_and_SV_type_NA12878_AM_full_exc_NA.png")
```



#### AM == "split"
```{r message=FALSE}
sample_size = large.split %>% group_by(ACMG_class) %>% summarize(num=n())

large.split %>%
  left_join(sample_size) %>%
  mutate(ACMG.class = paste0(ACMG_class, "\n (n=", num, ")")) %>%

ggplot(aes(x = ACMG.class, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="ACMG class", y="count") + 
    scale_fill_discrete(name = "SV type") +
    scale_y_continuous(name = "Count", breaks = c(0, 50000, 100000), labels = c("0", "50 K", "100 K")) +
    ggtitle("ACMG class and SV type in NA12878, AM=split")

ggsave2("ACMG_class_and_SV_type_NA12878_AM_split.png")

rm("sample_size")
```

We see that full=NA entries were almost exclusively the INV calls. Who made them?
```{r}
large.split %>%
  filter(SV_type == "INV") %>%
  ggplot(., aes(x = ACMG_class, fill=Caller)) + geom_bar() +
  labs(x="ACMG class", y="count") +
  ggtitle("Let's see who made those NA class INV calls...?")
```

```{r}
# similarly
large.split %>%
  filter(ACMG_class == "full=NA") %>%
  ggplot(., aes(x = SV_type, fill=Caller)) + geom_bar() + scale_y_log10() +
  labs(x="SV types having NA class", y="count") +
  ggtitle("Are they all INV? Made by whom, also?")
```


Note that **it seems like only SV_type == c("DEL", "DUP") are annotated with ACMG classes.** Biased much?


We proceed to filter the NA class out and rerun:
```{r message=FALSE}
filter(large.split, ACMG_class != "full=NA") %>%

ggplot(aes(x = ACMG_class, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="ACMG class", y="Count") +
    scale_x_discrete(breaks = c("full=1", "full=3", "full=4", "full=5"), label = c("1", "3", "4", "5")) +
    scale_fill_discrete(name = "SV type") +
    ggtitle("ACMG class and SV type in NA12878, excluding NA. AM=split")

ggsave2("ACMG_class_and_SV_type_NA12878_split_exc_NA.png")
```



### 6. Detected variants affecting CDS

```{r}
table(large.full$Location2)
```
This task requires AM == "Split".


#### 6-1. CDS-affecting SVs

```{r}
table(large.split$Location2)
```

We are interested in the variant calls affecting CDS regions. These include:
```{r}
filter(large.split, Location2 %in% c("5'UTR-3'UTR", "5'UTR-CDS", "CDS", "CDS-3'UTR")) %>%
  ggplot(aes(x = Location2, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="Gene topology", y="Count") +
    ggtitle("CDS-affecting SV type and variant topology in NA12878, AM=split")
```

For a clearer plot:
```{r}
# subset of AM=split data frame containing CDS-affecting entries --- AnnotSV-called
CDS.set <- filter(large.split, Location2 %in% c("5'UTR-3'UTR", "5'UTR-CDS", "CDS", "CDS-3'UTR"))
```


```{r message=FALSE}
# main plot
sample_size = CDS.set %>% group_by(Location2) %>% summarize(num=n())

CDS.set %>%
  left_join(sample_size) %>%
  mutate(topos = paste0(Location2, "\n (n=", num, ")")) %>%

ggplot(aes(x = topos, fill=SV_type)) +
    geom_bar() + scale_y_sqrt(breaks = c(10^4, 10^5, 2*10^5, 3*10^5), 
                              label = c("10 K", "100 K", "200 K", "300K")) +
    theme_bw() +
    labs(x="Gene topology", y="Count") + scale_fill_discrete(name = "SV type") +
    ggtitle("CDS-affecting SV type and variant topology in NA12878, AM=split")

ggsave2("CDS_affecting_SV_type_and_topology_NA12878.png")

rm("sample_size")
```

> Q: Why is the count (y)-axis inaccurate?

We scaled the count (Y) axis by sqrt(). Read on what biases it introduced.




```{r}
# try facet_wrap
CDS.set %>%
  ggplot(.) + aes(x = SV_type, fill=SV_type) + scale_y_continuous(trans = "log1p", 
                                                                  breaks = c(50, 1e3, 1e4, 1e5),
                                                                  label = c("50", "1K", "10 K", "100 K")) +
    geom_bar() + 
    facet_wrap( ~Location2) +
    theme_bw() +
    labs(x="Gene topology", y="Count") + scale_fill_discrete(name = "SV type") +
    ggtitle("CDS-affecting SV type and variant topology in NA12878, AM=split")

ggsave2("CDS_affecting_SV_type_and_topology_NA12878_wrapped.png")
```


To have a closer look on the variants affecting specifically only the CDS region, we subset:
```{r}
sample_size = CDS.set %>% filter(Location2 == "CDS") %>% group_by(SV_type) %>% summarize(num=n())

CDS.set %>%
  filter(Location2 == "CDS") %>%
  left_join(sample_size) %>%
  mutate(SV.type = paste0(SV_type, "\n (n=", num, ")")) %>%

  ggplot(.) + aes(x = SV.type, fill=SV_type) +
    geom_bar() + 
    theme_bw() +
    labs(x="SV type", y="Count") + scale_fill_discrete(name = "SV type") +
    ggtitle("CDS-affecting (exclusive) SV type in NA12878, AM=split")

ggsave2("CDS_affecting_exclusive_SV_type_NA12878.png")
```




#### 6-2. [ONGOING] The elite list

<1st layer: AnnotSV input>

    Raw call set %>% filter(PASS) %>% filter(ACMG = {4,5}) %>% 
    
    [R scripts]       [R scripts]           [Task 4]
    
<2nd layer>    

          filter(Called by e.g. at least 3 callers out of 5 used) %>% 
          [Task 3]
          
          
          filter(CDS-affecting) %>% 
          [Task 5]
          
          
          filter(Known to affect XX tissue)
          [This task]

```{r}
# check ACMG vs ACMG_class
table(as.factor(large.split$ACMG))
table(as.factor(large.split$ACMG_class))
```


```{r}
## TEST WORKFLOW TO BE COMPLETED
##
large.split %>% filter(ACMG_class %in% c("full=4", "full=5")) %>% ## select pathogenic variants 
  filter(Caller_count >= 3) %>% ## TODO new variable we will introduce at section 3
  filter(Location2 %in% c("5'UTR-3'UTR", "5'UTR-CDS", "CDS", "CDS-3'UTR")) %>% ## CDS-affecting
  filter(Tissue == "which") -> elite.variants.which ## TODO new variable to introduce at the end of (last) section 5-1

write.csv(elite.variants.which, "elite_var_affecting_which.csv")
```




[TBC]













### 7. nMDS-ExAC Z scores: A bundled measure of functional constraints per gene

The ExAC Z scores (read more at where?) are:

> ExAC_delZ,	ExAC_dupZ,	ExAC_cnvZ,	ExAC_synZ,	ExAC_misZ


Since they are Z scores ... they should approximately follow known distribution (SND)...right?


#### Workflow

--> Extract all ExAC data into numeric mtx
```{r}
# selecting a subset of SV size < 20 kb 
# as we are evaluating whether ExAC Z scores together are a good representation/estimate of 
# "functional constraint" corresponding to a gene-variant pair. We are hence omitting larger variants
# that likely span multiple genes.

# Also, vegan::metaMDS doesn't seem tolerate huge data frames well.

large.full %>%
  filter(between(SV_length, -20000, 20000)) %>%
  subset(select=c("ExAC_delZ",	"ExAC_dupZ",	"ExAC_cnvZ",	"ExAC_synZ",	"ExAC_misZ")) -> Z.mtx
```

--> Already standardised?



--> No NA, beware of zeros
```{r}
Z.mtx[complete.cases(Z.mtx), ] -> Z.mtx ## removes all rows containing any NA

#select(Z.mtx, -ExAC_misZ) -> Z.mtx

#Z.mtx <- decostand(Z.mtx, method= "max") ## TODO: omittable? Z score already a standardised measure.

round(Z.mtx$ExAC_cnvZ, 9) -> Z.mtx$ExAC_cnvZ
```


```{r}
# need to subsample. Last checked: Cap = 600
Z.mtx[sample(nrow(Z.mtx), 600), ] -> Z.mtx.sample
```


--> Apply similarity measure and MDS compression
```{r eval=FALSE}
MDS.S <- metaMDS(Z.mtx.sample, distance = "euclidean", autotransform = FALSE, trace = FALSE) ##TODO: proper distance measure?
```


--> Check stress level of MDS
```{r}
MDS.S$stress ## Checking MDS stress for interpretation
MDS.S$stress <= 0.20
```


Recall the standard level of acceptance of MDS stress = 0.20.


--> Obtain Cartesian coordinate in S_mtx
```{r}
MDS.xy <- data.frame(MDS.S$points) ## Sending the cartesian coordinates in MDS profile to MDS.xy
```


--> Send coordinate to new dummy df + assign factors of interest (e.g. Caller)

#### Assigning factors: Great code
```{r}
# precious codes
MDS.xy$Caller = large.full[match(row.names(MDS.xy), row.names(large.full)),"Caller"]

MDS.xy$ACMG_class = large.full[match(row.names(MDS.xy), row.names(large.full)),"ACMG_class"]

MDS.xy$SV_type = large.full[match(row.names(MDS.xy), row.names(large.full)),"SV_type"]

MDS.xy$SV_length = large.full[match(row.names(MDS.xy), row.names(large.full)),"SV_length"]

MDS.xy$SV_chrom = large.full[match(row.names(MDS.xy), row.names(large.full)),"SV_chrom"]
```


--> Run MDS plot and annotate with factor levels 

#### 7-1. ExACZ ~ Caller
```{r}
# MDS: (1) By Caller
ggplot(MDS.xy, aes(MDS1, MDS2, color = Caller)) + geom_point(size = 1) +
  
  #scale_colour_manual(values = wes_palette("GrandBudapest2")) +
  
  theme(axis.title = element_blank(),
        panel.background = element_rect(fill = "grey15", colour = "black", size = 1),
        #panel.grid.major = element_line(color = "grey30", size=0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.text = element_text(size = 11), 
        legend.title = element_text(size = 13.5),
        legend.key = element_rect(fill = NA)) +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  
  ggtitle("NMDS plot of five ExAC Z scores of variants grouped by variant caller in NA12878 \n (n=600)")

ggsave2("MDS_ExAC_Z_by_caller_NA12878.png")
```

No apparent clustering pattern (by Caller; n = 600).


#### 7-2. ExACZ ~ ACMG class
```{r}
# MDS: (2) By ACMG class of SV
MDS.xy$ACMG_class <- as.factor(MDS.xy$ACMG_class) ## coerce as factor level (discrete) instead of numeric (continuous)

ggplot(MDS.xy, aes(MDS1, MDS2, color = ACMG_class)) + geom_point() + theme_bw() +
  
  scale_colour_viridis(discrete = TRUE, name = "ACMG class") +
  
    theme(legend.key = element_rect(fill = NA),
        legend.text = element_text(size = 11),
        legend.title = element_text(size = 12),
        axis.title = element_blank(),
        panel.background = element_rect(fill = "grey97", colour = "black", size = 1),
        #panel.grid.major = element_line(color = "grey86", size=0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()
        ) + 
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  
  ggtitle("NMDS plot of five ExAC Z scores grouped by ACMG class of variants in NA12878 \n (n=600)")

ggsave2("MDS_ExAC_Z_by_ACMG_class_discrete_NA12878.png")
```


#### 7-3. ExACZ ~ SV type
```{r}
# MDS: (3) By SV type
ggplot(MDS.xy, aes(MDS1, MDS2, color = SV_type)) + geom_point(size = 1) +
  
  theme(axis.title = element_blank(),
        panel.background = element_rect(fill = "grey12", colour = "black", size = 1),
        #panel.grid.major = element_line(color = "grey30", size=0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_text(size = 12),
        legend.key = element_rect(fill = NA)) +
  
  scale_color_discrete(name = "SV type") +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  
  ggtitle("NMDS plot of five ExAC Z scores grouped by type of SV from NA12878 (n=600)")

ggsave2("MDS_ExAC_Z_by_SV_type_NA12878.png")
```

```{r}
table(as.factor(MDS.xy$SV_type))
```


```{r}
# Try facet_wrap
MDS.xy %>% filter(SV_type != "SVA") %>%
  ggplot(.) + aes(MDS1, MDS2, color = SV_type) + geom_point(size = 1) +
  
  theme(axis.title = element_blank(),
        panel.background = element_rect(fill = "grey12", colour = "black", size = 1),
        #panel.grid.major = element_line(color = "grey30", size=0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_text(size = 12),
        legend.key = element_rect(fill = NA)) +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  
  scale_color_discrete(name = "SV type") +
  
  facet_wrap( ~SV_type)
  
  ggtitle("NMDS plot of five ExAC Z scores grouped by type of structural \n variants in NA12878 (n=600)")

ggsave2("MDS_ExAC_Z_by_SV_type_NA12878_wrapped.png")
```



#### 7-4. ExACZ ~ SV length
```{r}
# MDS: (4) By SV length
MDS.xy %>% filter(!is.na(SV_length)) %>% mutate(SV_length = log10(abs(SV_length))) %>%

ggplot(aes(MDS1, MDS2, color = SV_length)) + geom_point(size = 1) +
  
  scale_color_viridis(option = "A") +
  
  theme(axis.title = element_blank(),
        panel.background = element_rect(fill = "grey12", colour = "black", size = 1),
        #panel.grid.major = element_line(color = "grey30", size=0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_text(size = 12),
        legend.key = element_rect(fill = NA)) +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  
  ggtitle("NMDS plot of five ExAC Z scores grouped by SV length in NA12878, n=600")

ggsave2("MDS_ExAC_Z_by_SV_length_NA12878.png")
```


#### 7-5. ExACZ ~ variant location
```{r}
# MDS: (5) By variant location
ggplot(MDS.xy, aes(MDS1, MDS2, color=SV_chrom)) + geom_point(size = 1) +
  
  theme(axis.title = element_blank(),
        panel.background = element_rect(fill = "grey12", colour = "black", size = 1),
        #panel.grid.major = element_line(color = "grey30", size=0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_text(size = 12),
        legend.key = element_rect(fill = NA)) +
  
  scale_color_discrete(name = "Chromosome") +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) +
  
  ggtitle("NMDS plot of five ExAC Z scores as measure of functional constraint \n grouped by chromosomal location from NA12878  (n=600)")

ggsave2("MDS_ExAC_Z_by_location_NA12878.png")
```


### 8. PCA:

#### 8-1. ExAC_Z continued: ACMG score and ExAC Z measure of functional constraint
```{r}
# using entire data frame instead of subsample as in MDS restrictions
Z.pca <- princomp(Z.mtx)
```

```{r}
# first-stage analysis
plot(Z.pca$scores) ## shows visuals of what first two PCs look like. can specify which = c(a,b)
screeplot(Z.pca) ## %var explained by each PC
summary(Z.pca) ## important statistics of each PC, mostly %var accounted
loadings(Z.pca) ## "loadings" in PCA refers to the linear (de)composition of each PC
```

Select PC1,2 = ~ 80%; PC1,2,3 = ~ 91% (Quite low!)

#### 2D PCA (80%)
```{r}
# PCA plot: 2D
Z.coor <- data.frame(Z.pca$scores)

# assigning factors
Z.coor$Caller = large.full[match(row.names(Z.coor), row.names(large.full)),"Caller"]
Z.coor$ACMG_class = large.full[match(row.names(Z.coor), row.names(large.full)),"ACMG_class"]
Z.coor$SV_type = large.full[match(row.names(Z.coor), row.names(large.full)),"SV_type"]
```


```{r}
# Plot 2D PCA
## by SV type
ggplot(Z.coor) + aes(Comp.1, Comp.2, color=SV_type) + geom_point() +
   theme_bw()

## by Caller
ggplot(Z.coor) + aes(Comp.1, Comp.2, color=Caller) + geom_point() +
   theme_bw()

## by ACMG class
Z.coor$ACMG_class <- as.factor(Z.coor$ACMG_class) ## discrete leveling

ggplot(Z.coor) + aes(Comp.1, Comp.2, color=ACMG_class) + geom_point() +
  scale_colour_viridis(discrete = TRUE) +
   theme_bw()
```


Consider subsample to n=600:

#### Subsampling: n=600
```{r}
# sample down to n=600
Z.coor[sample(nrow(Z.coor), 600), ] -> Z.pca.sample

# Plot 2D PCA
## by SV type
ggplot(Z.pca.sample) + aes(Comp.1, Comp.2, color=SV_type) + geom_point() +
   theme_bw()

## by Caller
ggplot(Z.pca.sample) + aes(Comp.1, Comp.2, color=Caller) + geom_point() +
   theme_bw()

## by ACMG class
ggplot(Z.pca.sample) + aes(Comp.1, Comp.2, color=ACMG_class) + geom_point() +
  scale_colour_viridis(discrete = TRUE) +
   theme_bw()
```


```{r}
Z.pca.sample %>% filter(SV_type != "SVA") %>%
  ggplot(.) + aes(Comp.1, Comp.2, color=SV_type) + geom_point() +
   theme_bw() + facet_wrap( ~SV_type)
```






## Section II. [w/ reference] Caller set {Delly, Manta, SvABA, Wham, Melt} against Gold Standard (NA12878 truth set)

### 1. [ONGOING] Precision, Recall, and FPR

#### Definition of terms

    - Precision = 1 - false discovery rate = 1 - FPR
    
    - Recall = 
    
















# Sandbox

## maestro.small: Small subset of benchmark.full / large.full, etc

```{r}
subset(benchmark.full, 
       
       select=c("AnnotSV_ID",	"SV_chrom",	"SV_start",	"SV_end",	"SV_length",	"SV_type",	"Samples_ID",	"ID",	"REF",	"ALT",	"QUAL",	"FILTER",	"INFO", "CytoBand",	"Gene_name",	"Gene_count", "ExAC_delZ",	"ExAC_dupZ",	"ExAC_cnvZ",	"ExAC_synZ",	"ExAC_misZ","OMIM_morbid",	"OMIM_morbid_candidate","GnomAD_pLI",	"ExAC_pLI",	"AnnotSV_ranking_score",	"AnnotSV_ranking_criteria",	"ACMG_class",	"Coverage", "Caller")) -> maestro.small
```


# Footnotes

1. Reference: Cameron, D. L., et al. (2019). "Comprehensive evaluation and characterisation of short read general-purpose structural variant calling software." Nature Communications 10(1): 3240.




