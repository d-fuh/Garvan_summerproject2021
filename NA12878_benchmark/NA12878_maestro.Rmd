---
title: "Benchmarking NA12878 SVs by different callers"
edition: "Maestro"
date: "Jan 13, 2022"
output: html_notebook
---
# Version updates

This is version "Maestro 1.0". 

We moved relevant codes from the old NA12878_benchmark.rmd to this notebook, and aim to use the maestro file for all analyses. (See maestro_generation.R)


# Prerequisites

For pre-processing files, you will need:

  - All NA12878-derived (against GRCh38) VCF outputs from callers {Delly, Manta, Melt, Wham, SvABA}, from the workflow GATK-SV.
  - Note that SvABA output was from its own workflow independent of GATK-SV.


You will then need to process these files via AnnotSV (cf. ReadME). The settings are described on ReadME.


For the R scripts for processing these VCF files, you will need:

  - maestro_generation_full.R (For Annotation_mode == "full")
  - maestro_generation_split.R (For Annotation_mode == "split")


Finally, to run this notebook, you will need:

  - benchmark.full (Data frame containing AnnotSV products from all callers in all subsets of NA12878, using "full" mode)
  - benchmark.split (Same, except using "split" mode)


To start the workflow, go to #Main.


```{r}
# remove any trace of previous versions
rm(benchmark.master)
rm(benchmark.annot)
```


# Filtering and processing notes:

    1) FILTER == "PASS"
    2) (Section 6 onwards using maestro.small) -20,000 <= SV_length <= 20,000 (bp)


# Working notes


- See tabs with [ONGOING] in the header for items currently still being worked on. They include:

    1. SV_length: Suspect confounder in the AM=split set. Try filter between(SV_length, -20000, 20000) and see if any interesting difference occurs.
    
    2. Creating a SV aggregation workflow with relaxed criteria
    3. Remaining items in #TO-DO


## TO-DO

- **TODO**: Find gold standard NA12878 SV call set ("truth set")
- **TODO**: Include supporting reads info
- **TODO**: Assign figure numbers to each (important) figures to export (ggsave bug)



# Introduction

See ReadME.md.



# Main 

Before you start, run:
```{r}
# always double-check
table(as.factor(benchmark.full$FILTER))
table(as.factor(benchmark.split$FILTER))
```

You should only see one level in the two data frames tested --- "PASS".


## Packages

```{r message=FALSE}
library(tidyverse)
library(vcfR)
library(vegan)
library(viridis)
library(wesanderson) ## optional
```


## Analysis

### 1. SV call location across NA12878 by different callers

```{r}
# Reordering SV_chrom axis
benchmark.full$SV_chrom <- factor(benchmark.full$SV_chrom, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "X", "Y", "M"))

```

> Q: Explain recordings in the Y chromosome.


> NB: Both benchmark.full and benchmark.split contain overlayed information from the small, medium, and large set. As a result, it creates spikes that are artefacts which confounds the results if not removed. We will "filter the real data" back to a clean data frame in which only those calls from the "Large" NA12878 set is used.


```{r}
large.full <- filter(benchmark.full, Coverage == "Large")
large.split <- filter(benchmark.split, Coverage == "Large")
```

```{r}
table(benchmark.full$SV_chrom)
table(large.full$SV_chrom)
```


#### 1-1. SV location by callers: OR IS IT?

```{r message=FALSE}
# THIS IS AN INCORRECT GRAPH
ggplot(benchmark.full, aes(x = SV_chrom, fill=Caller)) +
    geom_bar() + #scale_y_log10() +
    theme_bw() + theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust = 1.2)) +
    labs(x="Chromosome", y="count") + 
    ggtitle("SV location by different callers in NA12878 using AnnotSV, AM = full \n --- MISREPRESENTATION")
```

This is inaccurate --- if you try to explain the spike in Chr#20 (it's not any bigger physically), you'll see it's due to the fact we've aggregated the data set (small, med, large) altogether. The resultant file has over-condensation on certain chromosomes.

This is evident when we split the counts apart by their Coverage column:

#### 1-2. SV location by coverage (small, medium, large)

```{r message=FALSE}
benchmark.full %>%
  group_by(Coverage, SV_chrom) %>%
    summarise(mean.A = mean(n()),
    sd.A = sd(n()),
    SE.A = sd(n())/sqrt(n())) %>%

  ggplot(aes(SV_chrom, mean.A, fill=Coverage)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    
    geom_errorbar(aes(ymin = mean.A-SE.A, ymax = mean.A+SE.A), width = 0.3, position = position_dodge(0.9)) +
    ylab("Count") + xlab("Chromosome") +
    theme_classic()
```

We see that the pink column is the true graph we wanted in Section 1-1. We will generate it by

#### 1-3. SV location by callers

```{r}
large.full %>%

ggplot(aes(x = SV_chrom, fill=Caller)) +
    geom_bar() +
    theme_bw() +
    labs(x="Chromosome", y="count") + 
    ggtitle("SV location by different callers in NA12878 using AnnotSV, AM = full") -> F1

F1
```




### 2. SV type by caller 

#### 2-1. Including special classes {ALU, BND, LINE1, SVA} from Melt, Manta and SvABA

```{r message=FALSE}
sample_size = large.full %>% group_by(SV_type) %>% summarize(num=n())

large.full %>%
  left_join(sample_size) %>%
  mutate(svtype = paste0(SV_type, "\n (n=", num, ")")) %>%

ggplot(aes(x = svtype, fill=Caller)) +
    geom_bar() + #scale_y_log10() +
    theme_bw() +
    labs(x="Type of SV", y="count") +
    ggtitle("Types of structural variants detected by different callers in NA12878") -> F2

rm("sample_size")

F2
```


#### 2-2. [LATER?] Synthesising SV types to four simple SV events: {DEL, DUP, INS, INV}











#### 2-3. Wrapping SV types with coverage level (Small, Medium, Large NA12878)

```{r message=FALSE}
benchmark.full %>%
  group_by(Coverage, SV_type) %>%
    summarise(mean.A = mean(n()),
    sd.A = sd(n()),
    SE.A = sd(n())/sqrt(n())) %>%
# Bar plot
  ggplot(aes(SV_type, mean.A, fill=Coverage)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    
    geom_text(aes(label = paste(round(mean.A, 0))), position = position_dodge(0.7), 
              vjust =0.0, hjust=0.6, size = 3.5) + ## labels mean data on top of bar
    
    geom_errorbar(aes(ymin = mean.A-SE.A, ymax = mean.A+SE.A), width = 0.3, position = position_dodge(0.9)) +
    ylab("Count") + xlab("SV Type") +
    theme_classic() +
    ggtitle("SV types detected by various callers in NA12878") -> F3

F3
```






### 3. Number of variants detected by all methods

```{r eval=FALSE}
table(as.factor(large.full$Caller))
```

We want to know: Are any of these calls made by multiple callers? We take the following approach.

> Let %CI == "a set standard" (e.g. 0.1% of SV_length), then define two given SV calls match if and only if:


      start_A is within [start_B +- %CI] 
      
      && 
      
      end_A is within [end_B +- %CI]
      
> ... and we can use the original workflow to aggregate the Callers for same SV calls (as defined above).


#### [ONGOING] Use data.table
#### [ONGOING] Use GenomicRanges::findOverlap













### 4. ACMG class of variants

```{r}
# first, see the distribution of ACMG class in annotated data
table(large.full$ACMG_class)
table(large.split$ACMG_class) ## any difference?
```

Note that for benchmark.full, the NA rows did not show up here.


#### AM == "Full"

```{r message=FALSE}
sample_size = large.full %>% group_by(ACMG_class) %>% summarize(num=n())

large.full %>%
  left_join(sample_size) %>%
  mutate(ACMG.class = paste0(ACMG_class, "\n (n=", num, ")")) %>%

ggplot(aes(x = ACMG.class, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="ACMG class", y="Count") +
    ggtitle("ACMG class and SV type detected by various callers from NA12878, AM=full") -> F4.1

rm("sample_size")

F4.1
```

Try removing the NA rows:

```{r message=FALSE}
filter(large.full, ACMG_class != "full=NA") %>%

ggplot(aes(x = ACMG_class, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="ACMG class", y="count") +
    ggtitle("ACMG class and SV type by callers from NA12878, excluding NA. AM=full") -> F4.2

F4.2
```



#### AM == "split"
```{r message=FALSE}
sample_size = large.split %>% group_by(ACMG_class) %>% summarize(num=n())

large.split %>%
  left_join(sample_size) %>%
  mutate(ACMG.class = paste0(ACMG_class, "\n (n=", num, ")")) %>%

ggplot(aes(x = ACMG.class, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="ACMG class", y="count") +
    ggtitle("ACMG class and SV type detected by various callers in NA12878, AM=split") -> F4.3

rm("sample_size")

F4.3
```

We see that full=NA entries were mostly INV called by SvABA.

We proceed to filter them out and rerun to find anything interesting:
```{r message=FALSE}
filter(large.split, ACMG_class != "full=NA") %>%

ggplot(aes(x = ACMG_class, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="ACMG class", y="count") +
    ggtitle("ACMG class and SV type by callers from NA12878, excluding NA. AM=split") -> F4.4

F4.4
```



### 5. Detected variants affecting CDS

```{r}
table(large.full$Location2)
```
This task requires AM == "Split".


#### 5-1. CDS-affecting SVs

```{r}
table(large.split$Location2)
```

We are interested in the variant calls affecting CDS regions. These include:
```{r}
filter(large.split, Location2 %in% c("5'UTR-3'UTR", "5'UTR-CDS", "CDS", "CDS-3'UTR")) %>%
  ggplot(aes(x = Location2, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="Gene topology", y="Count") +
    ggtitle("CDS-affecting SV type and variant topology from NA12878, AM=split")
```

For a clearer plot:
```{r}
# subset of split data frame containing CDS-affecting entries --- AnnotSV-called
CDS.set <- filter(large.split, Location2 %in% c("5'UTR-3'UTR", "5'UTR-CDS", "CDS", "CDS-3'UTR"))
```


```{r message=FALSE}
# main plot
sample_size = CDS.set %>% group_by(Location2) %>% summarize(num=n())

CDS.set %>%
  left_join(sample_size) %>%
  mutate(topos = paste0(Location2, "\n (n=", num, ")")) %>%

ggplot(aes(x = topos, fill=SV_type)) +
    geom_bar() + scale_y_sqrt() +
    theme_bw() +
    labs(x="Gene topology", y="Count") +
    ggtitle("CDS-affecting SV type and variant topology from NA12878, AM=split") -> F5

rm("sample_size")

F5
```

> Q: Why is the count (y)-axis inaccurate?




#### 5-2. [ONGOING] The elite list

<1st layer: AnnotSV input>

    Raw call set %>% filter(PASS) %>% filter(ACMG = {4,5}) %>% 
    
    [R scripts]       [R scripts]           [Task 4]
    
<2nd layer>    

          filter(Called by e.g. at least 3 callers out of 5 used) %>% 
          [Task 3]
          
          
          filter(CDS-affecting) %>% 
          [Task 5]
          
          
          filter(Known to affect XX tissue)
          [This task]


[TBC]



### 6. Sandbox

#### maestro.small

```{r}
subset(benchmark.full, select=c("AnnotSV_ID",	"SV_chrom",	"SV_start",	"SV_end",	"SV_length",	"SV_type",	"Samples_ID",	"ID",	"REF",	"ALT",	"QUAL",	"FILTER",	"INFO", "CytoBand",	"Gene_name",	"Gene_count", "ExAC_delZ",	"ExAC_dupZ",	"ExAC_cnvZ",	"ExAC_synZ",	"ExAC_misZ","OMIM_morbid",	"OMIM_morbid_candidate","GnomAD_pLI",	"ExAC_pLI",	"AnnotSV_ranking_score",	"AnnotSV_ranking_criteria",	"ACMG_class",	"Coverage", "Caller")) -> maestro.small
```

Later, we can eliminate column with all NA by "some method". Note this is largely due to Annotation_mode =="full".


---------------------------------------------------------IGNORE BELOW CODE-------------------------------------------------------

### 6-2. SV length ~ Coverage/Caller: ANOVA

#### Filtering based on size

There are some massive SVs reported by Delly...should we remove them?
```{r}
maestro.small %>%
  filter(between(SV_length, -20000, 20000)) -> maestro.small
```

```{r}
range(maestro.small$SV_length)
```


> NB: SvABA reported mostly indels...of course (called "BND") (Check yourself with SV_start & SV_end)
> These calls has SV_length == NA, which is problematic
> Need filter


```{r message=FALSE}
maestro.small %>%
  filter(!is.na(SV_length)) %>%
  filter(SV_length > 1) %>% ## ignoring SNV/BND
  ggplot(aes(x=log10(SV_length))) + geom_histogram(binwidth = 0.05) + xlab("log SV length excluding SNV/BND")
```

```{r}
maestro.small %>%
  filter(!is.na(SV_length)) %>%
  filter(SV_length > 1) %>% ## ignoring SNV/BND
  ggplot(aes(x=SV_length)) + geom_histogram(binwidth = 0.05) + scale_x_log10() + xlab("SV length excluding SNV/BND") +
  theme_bw()
```

```{r}
# ignoring SNV/BND
maestro.small %>%
  filter(!is.na(SV_length)) %>%
  filter(SV_length > 1) -> noSNV

mean(noSNV$SV_length)
median(noSNV$SV_length)
```


```{r message=FALSE}
# Note that in noSNV, maestro.small the SV calls were bounded to [-20000, 20000].
ggplot(noSNV, aes(x=SV_type, y=SV_length, fill=SV_type)) + geom_boxplot() + scale_y_log10() +
  ylab("SV length") + xlab("SV type, excluding SNV and BND") +
  theme_bw() +
  ggtitle("SV_length_vs_type_excluding_SNV_BND_NA12878")
```


```{r message=FALSE}
# Want to know SV length dist. based on callers
# Note that in noSNV, maestro.small the SV calls were bounded to [-20000, 20000].
noSNV %>%
  ggplot(aes(x=Caller, y=SV_length, fill=Caller)) + geom_boxplot() + scale_y_log10() +
    theme_bw() + ggtitle("SV_length_among_callers_NA12878.png")
```

---------------------------------------------------------IGNORE ABOVE CODE-------------------------------------------------------

### 6-3. ExAC Z scores: MDS, colour by Coverage/Caller

The ExAC Z scores (read more at where?) are:

> ExAC_delZ,	ExAC_dupZ,	ExAC_cnvZ,	ExAC_synZ,	ExAC_misZ


Since they are Z scores ... they should approximately follow known distribution (SND)...right?


#### Workflow

--> Extract all ExAC data into numeric mtx
```{r}
large.full %>%
  filter(between(SV_length, -20000, 20000)) %>%
  subset(select=c("ExAC_delZ",	"ExAC_dupZ",	"ExAC_cnvZ",	"ExAC_synZ",	"ExAC_misZ")) -> Z.mtx
```

--> Already standardised?



--> No NA, beware of zeros
```{r}
Z.mtx[complete.cases(Z.mtx), ] -> Z.mtx ## removes all rows containing any NA

#select(Z.mtx, -ExAC_misZ) -> Z.mtx

Z.mtx <- decostand(Z.mtx, method= "max")

round(Z.mtx$ExAC_cnvZ, 9) -> Z.mtx$ExAC_cnvZ
```


```{r}
# need to subsample. Last checked: Cap = 600
Z.mtx[sample(nrow(Z.mtx), 600), ] -> Z.mtx.sample
```


--> Apply similarity measure and MDS compression
```{r eval=FALSE}
MDS.S <- metaMDS(Z.mtx.sample, distance = "euclidean", autotransform = FALSE, trace = FALSE)
```


--> Check stress level of MDS
```{r}
MDS.S$stress ## Checking MDS stress for interpretation
MDS.S$stress <= 0.20
```


Recall the standard level of acceptance of MDS stress = 0.20.


--> Obtain Cartesian coordinate in S_mtx
```{r}
MDS.xy <- data.frame(MDS.S$points) ## Sending the cartesian coordinates in MDS profile to MDS.xy
```


--> Send coordinate to new dummy df + assign factors of interest (e.g. Caller)

```{r}
# precious codes
MDS.xy$Caller = large.full[match(row.names(MDS.xy), row.names(large.full)),"Caller"]

MDS.xy$ACMG_class = large.full[match(row.names(MDS.xy), row.names(large.full)),"ACMG_class"]

MDS.xy$SV_type = large.full[match(row.names(MDS.xy), row.names(large.full)),"SV_type"]

#MDS.xy$SV_length = large.full[match(row.names(MDS.xy), row.names(large.full)),"SV_length"]
```


--> Run MDS plot and annotate with factor levels 

#### MDS sample plots
```{r}
# MDS: (1) By Caller
ggplot(MDS.xy, aes(MDS1, MDS2, color = Caller)) + geom_point(size = 1) +
  
  #scale_colour_manual(values = wes_palette("GrandBudapest2")) +
  
  theme(axis.title = element_blank(),
        panel.background = element_rect(fill = "grey15", colour = "black", size = 1),
        #panel.grid.major = element_line(color = "grey30", size=0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.text = element_text(size = 11), 
        legend.title = element_text(size = 13.5),
        legend.key = element_rect(fill = NA)) +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) -> F6

F6
```


```{r}
# MDS: (2) By ACMG class of SV
ggplot(MDS.xy, aes(MDS1, MDS2, color = ACMG_class)) + geom_point() + theme_bw() +
  
  scale_colour_viridis() +
  
    theme(legend.key = element_rect(fill = NA),
        legend.text = element_text(size = 11),
        legend.title = element_text(size = 12),
        axis.title = element_blank(),
        panel.background = element_rect(fill = "grey97", colour = "black", size = 1),
        #panel.grid.major = element_line(color = "grey86", size=0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        aspect.ratio = 7 / 9.9
        ) -> F7

F7
```

```{r}
# MDS: (3) By SV type
ggplot(MDS.xy, aes(MDS1, MDS2, color = SV_type)) + geom_point(size = 1) +
  
  theme(axis.title = element_blank(),
        panel.background = element_rect(fill = "grey12", colour = "black", size = 1),
        #panel.grid.major = element_line(color = "grey30", size=0.1),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        legend.title = element_text(size = 12),
        legend.key = element_rect(fill = NA)) +
  
  guides(color = guide_legend(override.aes = list(size = 4.5))) -> F8

F8
```

[END MDS]


# Figures
```{r}

```







