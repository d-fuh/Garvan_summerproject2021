---
title: "Benchmarking NA12878 SVs by different callers"
edition: "Maestro"
date: "Jan 12, 2022"
output: html_notebook
---
# Version updates

This is version 1.0 of the Maestro file. We moved relevant codes from the old NA12878_benchmark.rmd to this notebook, and aim to use the maestro file for all analyses. (See maestro_generation.R)

```{r}
rm(benchmark.master)
rm(benchmark.annot)
rm(common.variants)
rm(gc.cap)
rm(svtype)
```


# Working notes

***NB: Annotation_mode == "Split" is required to analyse gene topology info required for CDS analysis.***


- See tabs with [ONGOING] in the header for items currently still being worked on;
- These include:

    1. Synthesis by SV types into four simple classes
    2. Creating a SV aggregation workflow with relaxed criteria
    3. Generating a wrapped bar plot using SV types and multiple coverage levels


# Filtering and processing notes:

    1) FILTER == "PASS"
    2) We will try to include supporting reads info on the 2nd edition workflow;
    3) Currently awaiting gold standard NA12878 SV call set ("truth set")

    
```{r}
filter(benchmark.annot.maestro, FILTER == "PASS") -> benchmark.maestro
rm(benchmark.annot.maestro)
```

```{r}
# always double-check
table(as.factor(benchmark.annot.maestro$FILTER))
table(as.factor(benchmark.annot$FILTER))
table(as.factor(benchmark.master$FILTER))
table(as.factor(s.benchmark.master$FILTER))
table(as.factor(m.benchmark.annot$FILTER))
```

You should only see one level in all of the dataframes tested --- "PASS".



# Introduction

See ReadME.md.



# Main 

## Data loading and processing: Benchmark.maestro

See R script "maestro_generation" to generate a fully-annotated "maestro" file containing annotated VCF @fix columns from NA12878 and its two subsets, small and medium NA12878.

```{r message=FALSE}
library(tidyverse)
library(vcfR)
library(GenomicRanges)
library(vegan)
```


## Analysis

### 1. SV call location across NA12878 by different callers

```{r}
# Reordering SV_chrom axis
benchmark.maestro$SV_chrom <- factor(benchmark.maestro$SV_chrom, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "X", "Y", "M"))
table(benchmark.maestro$SV_chrom)
```


```{r message=FALSE}
ggplot(benchmark.maestro, aes(x = SV_chrom, fill=Caller)) +
    geom_bar() + #scale_y_log10() +
    theme_bw() + theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust = 1.2)) +
    labs(x="Chromosome", y="count") + 
    ggtitle("SV location by different callers in NA12878 using AnnotSV")

ggsave("SV_location_NA12878_maestro_annotSV.png")
```

## 2. SV type by caller 

### 2-1. Including special classes {ALU, BND, LINE1, SVA} from Melt, Manta and SvABA

```{r message=FALSE}
sample_size = benchmark.maestro %>% group_by(SV_type) %>% summarize(num=n())

benchmark.maestro %>%
  left_join(sample_size) %>%
  mutate(svtype = paste0(SV_type, "\n (n=", num, ")")) %>%

ggplot(aes(x = svtype, fill=Caller)) +
    geom_bar() + #scale_y_log10() +
    theme_bw() +
    labs(x="Type of SV", y="count") +
    ggtitle("Types of structural variants detected by different callers in NA12878")

ggsave("SV_type_NA12878_maestro.png")

rm("sample_size")
```


### 2-2. [ONGOING] Synthesising SV types to four simple SV events: {DEL, DUP, INS, INV}











### 2-3. [ONGOING] Wrapping SV types with coverage level (Small, Medium, Large NA12878)

```{r message=FALSE}
benchmark.annot.maestro %>%
  group_by(Coverage, SV_type) %>%
    summarise(mean.A = mean(n()),
    sd.A = sd(n()),
    SE.A = sd(n())/sqrt(n())) %>%
# Bar plot
  ggplot(aes(SV_type, mean.A, fill=Coverage)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    
    geom_text(aes(label = paste(round(mean.A, 0))), position = position_dodge(0.7), 
              vjust =0.0, hjust=0.7, size = 3.5) + ## labels mean data on top of bar
    
    geom_errorbar(aes(ymin = mean.A-SE.A, ymax = mean.A+SE.A), width = 0.3, position = position_dodge(0.9)) +
    ylab("Count") + xlab("SV Type") +
    theme_classic()

ggsave("SV_type_by_coverage_annotated_NA12878.png")
```






## 3. [ONGOING] Number of variants detected by all methods

```{r eval=FALSE}
table(as.factor(benchmark.maestro$Caller))
```

We want to know: Are any of these calls made by multiple callers? We take the following approach.

> Let CI% == "a set standard (0.1%?)", then define two given SV calls match if and only if,

      start_A %in% [start_std +- CI%] && end_A %in% [end_std +- CI%]
      
> ... and we can use the original workflow to aggregate the Callers for same SV calls (as defined above).

-----------------------------------------------------TO BE DELETED::START--------------------------------------------------------

### This is a previous example in which we used the "strict" definition of "matching SV calls"

```{r}
# double-checking our results using AnnotSV files
subset(benchmark.maestro, select = c("SV_start", "SV_end", "SV_type", "ID", "Caller")) -> cant.pipe

aggregate(cant.pipe[5], cant.pipe[-5], unique) -> place.holder

place.holder$ID <- NULL

aggregate(place.holder[4], place.holder[-4], FUN = function(X) paste(unique(X), collapse=", ")) -> common.variants

# checking callers power set distribution
table(as.factor(common.variants$Caller))

# plot
sample_size = common.variants %>% group_by(Caller) %>% summarize(num=n())

common.variants %>%
  left_join(sample_size) %>%
  mutate(caller = paste0(Caller, "\n (n=", num, ")")) %>%

ggplot(aes(x = caller, fill=SV_type)) +
    geom_bar() +
    theme_bw() +
    labs(x="SV Caller", y="count") +
    ggtitle("Number of structural variants detected by each caller in NA12878")

rm("sample_size")
rm("cant.pipe")
rm("place.holder")
rm("common.variants")
```




### [ONGOING] Aggregating caller set in master file using relaxed SV matching criteria

  In the first edition, we used "Start = Start && end = end" as the criteria for matching SV calls;
        
  This appeared too strict, as many calls do not have multiple callers reported.
        
  We will change this criterion to:
        
        Start <belongs to> [Start_std +- CI%] && end <belongs to> [End_std +- CI%]


The idea is to:
    - 1. Form a smaller subset from annotated master file first --- this contains SV location, and basic profile such as caller used, SV type, ACMG class, and gene topology.
    
    - 2. From this subset: For any two calls (made by different callers, suppose there are no duplicates, including multiple split annotations for one SV), if:
    
        df.subset %>%  
            
            SV_start_A between() SV_start_B +- 0.02*SV_start_B &&
            SV_end_A between() SV_end_B +- 0.02*SV_end_B
        then return TRUE --> aggregate the two rows by "Caller", delimiter = ','
      ...and repeat this process for all entries. Send new data frame back to the original subset. 

In the resultant df, we should expect:

      Calls considered the same call are grouped into one entry, with $Caller == all callers that called this SV
      
i.e.,      

     | start        | end           | ... other variables ... | Caller                      |
     |:------------:|---------------|:-----------------------:|----------------------------:|
     | 53218-20     | 53421-24      | ...                     | Delly, Manta                |
     | 61385        | 63267         | ...                     | Delly                       |
     | ...          | ...           | ...                     | ...                         |

One way to do this is to group start:end into one column, designated "SV_range":
...

(see package "data.table")

-----------------------------------------------------TO BE DELETED::END----------------------------------------------------------


### [ONGOING] Use GenomicRanges::findOverlap()













## 4. [SPLIT] ACMG class of variants

```{r}
# first, see the distribution of ACMG class in annotated data
table(as.factor(benchmark.annot.maestro$ACMG_class))
```

The following chunk is for when Annotation_mode included "split" during AnnotSV generation.


-----START OF OPTIONAL CHUNK-----

```{r eval=FALSE, include=FALSE}
# cleaning calls of NA pathogenicity class
filter(benchmark.annot, ACMG_class != "full=NA") -> benchmark.ACMG

# joining full and split mode calls
# by directly forcing "full=x" -> 'x'
benchmark.ACMG[benchmark.ACMG == "full=1"] <- "1"
benchmark.ACMG[benchmark.ACMG == "full=3"] <- "3"
benchmark.ACMG[benchmark.ACMG == "full=4"] <- "4"
benchmark.ACMG[benchmark.ACMG == "full=5"] <- "5"
```

-----END OF OPTIONAL CHUNK-----



```{r message=FALSE}
sample_size = benchmark.maestro %>% group_by(ACMG_class) %>% summarize(num=n())

benchmark.maestro %>%
  left_join(sample_size) %>%
  mutate(ACMG.class = paste0(ACMG_class, "\n (n=", num, ")")) %>%

ggplot(aes(x = ACMG.class, fill=SV_type)) + # can try fill=Caller next
    geom_bar() +
    theme_bw() +
    labs(x="ACMG class", y="count") +
    ggtitle("ACMG class and SV type detected by various callers in NA12878")

ggsave("ACMG_NA12878_maestro.png")

rm("sample_size")
```



## 5. [SPLIT] Detected variants affecting CDS

```{r}
table(as.factor(benchmark.annot.maestro$Location2))
```
Yeah, this requires Annotation_mode == "Split"...

### 5-1. CDS-affecting SVs

### 5-2. The elite list

<1st layer: AnnotSV input level>

    Raw call set %>% filter(PASS) %>% filter(ACMG = {4,5}) %>% 
    
<2nd layer:>    

          filter(Called by e.g. at least 3 callers out of 5 used) %>% filter(CDS-affecting) %>% filter(Known to affect XX tissue)

We will carry out this work later when we generate a bunch of split files.



## 6. Sandbox

```{r}
subset(benchmark.annot.maestro, select=c("AnnotSV_ID",	"SV_chrom",	"SV_start",	"SV_end",	"SV_length",	"SV_type",	"Samples_ID",	"ID",	"REF",	"ALT",	"QUAL",	"FILTER",	"INFO", "CytoBand",	"Gene_name",	"Gene_count", "ExAC_delZ",	"ExAC_dupZ",	"ExAC_cnvZ",	"ExAC_synZ",	"ExAC_misZ","OMIM_morbid",	"OMIM_morbid_candidate","GnomAD_pLI",	"ExAC_pLI",	"AnnotSV_ranking_score",	"AnnotSV_ranking_criteria",	"ACMG_class",	"Coverage", "Caller")) -> maestro.small
```

Later, we can eliminate column with all NA by "some method". Note this is largely due to Annotation_mode =="full".


### 6-1. SV location by coverage level

```{r message=FALSE}
# reorder the chrom #
maestro.small$SV_chrom <- factor(maestro.small$SV_chrom, levels=c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "X", "Y", "M"))

maestro.small %>%
  group_by(Coverage, SV_chrom) %>%
    summarise(mean.A = mean(n()),
    sd.A = sd(n()),
    SE.A = sd(n())/sqrt(n())) %>%
# Bar plot
  ggplot(aes(SV_chrom, mean.A, fill=Coverage)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    
    #geom_text(aes(label = paste(round(mean.A, 0))), position = position_dodge(0.7), 
              #vjust =0.0, hjust=0.7, size = 3.5) + ## labels mean data on top of bar
    
    geom_errorbar(aes(ymin = mean.A-SE.A, ymax = mean.A+SE.A), width = 0.3, position = position_dodge(0.9)) +
    ylab("Count") + xlab("Chromosome") +
    theme_classic()

ggsave("SV_location_by_coverage_NA12878.png")
```

### 6-2. SV length ~ Coverage/Caller: ANOVA

```{r}
plot(maestro.small$SV_length) ## see distribution
```


Filtering based on size?

> NB: SvABA reported mostly indels...of course (called "BND") (Check yourself with SV_start & SV_end)
> These calls has SV_length == NA, which is problematic
> Need filter


```{r message=FALSE}
maestro.small %>%
  filter(!is.na(SV_length)) %>%
  filter(SV_length > 1) %>% ## ignoring SNV/BND
  ggplot(aes(x=log10(SV_length))) + geom_histogram() + xlab("log SV length excluding SNV/BND")
```

```{r}
maestro.small %>%
  filter(!is.na(SV_length)) %>%
  filter(SV_length > 1) %>%
    mean(SV_length)
```



```{r message=FALSE}
# Want to know SV length dist. based on callers
maestro.small %>%
  filter(!is.na(SV_length)) %>%
  filter(SV_length > 1) %>% ## ignoring SNV/BND
  
  ggplot(aes(x=Caller, y=log10(SV_length))) + geom_boxplot() + # best transform?
    theme_bw()

ggsave("SV_length_among_callers_NA12878.png")
```


geom_violin next?


```{r}
# Want to know SV length dist. based on callers using violin plot
maestro.small %>%
  filter(!is.na(SV_length)) %>%
  filter(SV_length > 1) %>% ## ignoring SNV/BND
  
  ggplot(aes(x=Caller, y=log10(SV_length))) + geom_violin() + # best transform?
    theme_bw()

#ggsave("SV_length_among_callers_NA12878_violin.png")
```



### 6-3. ExAC Z scores: MDS, colour by Coverage/Caller

The ExAC Z scores (read more at where?) are:

> ExAC_delZ,	ExAC_dupZ,	ExAC_cnvZ,	ExAC_synZ,	ExAC_misZ


Since they are Z scores .... known distribution (SND).

#### Workflow

--> Extract all ExAC data into numeric mtx
--> Already standardised?
--> No NA, beware of zeros
--> Apply similarity measure (Euclidean first?)
--> S mtx


--> metaMDS(S_mtx)
--> Obtain Cartesian coordinate in S_mtx
--> Send to new dummy df + assign factors of interest (e.g. Caller)
--> Run MDS plot and annotate with factor levels #




